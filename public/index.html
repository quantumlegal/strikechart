<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Primary Meta Tags -->
  <title>Signal Sense Hunter - Real-Time Crypto Volatility Scanner</title>
  <meta name="title" content="Signal Sense Hunter - Real-Time Crypto Volatility Scanner">
  <meta name="description" content="Professional real-time volatility detection system for Binance Futures. Track 580+ trading pairs, identify high-momentum opportunities, volume spikes, and smart trading signals before they become obvious.">
  <meta name="keywords" content="crypto trading, binance futures, volatility scanner, trading signals, cryptocurrency, bitcoin, altcoins, volume spikes, momentum trading, real-time alerts, crypto scanner, trading dashboard">
  <meta name="author" content="Signal Sense Hunter">
  <meta name="robots" content="index, follow">
  <meta name="language" content="English">
  <meta name="revisit-after" content="1 days">

  <!-- Canonical URL -->
  <link rel="canonical" href="https://signalsense.trade/">

  <!-- Theme Color -->
  <meta name="theme-color" content="#0a0e17">
  <meta name="msapplication-TileColor" content="#0a0e17">
  <meta name="msapplication-navbutton-color" content="#d29922">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Signal Sense">

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://signalsense.trade/">
  <meta property="og:title" content="Signal Sense Hunter - Real-Time Crypto Volatility Scanner">
  <meta property="og:description" content="Professional real-time volatility detection for Binance Futures. Track 580+ pairs, identify momentum opportunities, volume spikes, and smart trading signals.">
  <meta property="og:image" content="https://signalsense.trade/og-image.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:site_name" content="Signal Sense Hunter">
  <meta property="og:locale" content="en_US">

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://signalsense.trade/">
  <meta property="twitter:title" content="Signal Sense Hunter - Real-Time Crypto Volatility Scanner">
  <meta property="twitter:description" content="Professional real-time volatility detection for Binance Futures. Track 580+ pairs, identify momentum opportunities and smart trading signals.">
  <meta property="twitter:image" content="https://signalsense.trade/og-image.png">

  <!-- Favicons -->
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">

  <!-- Preconnect for performance -->
  <link rel="preconnect" href="https://fstream.binance.com">
  <link rel="dns-prefetch" href="https://fstream.binance.com">

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // Production Security Module
    (function() {
      'use strict';

      // Check if in production (loaded via HTTPS or specific domain)
      const isProduction = location.protocol === 'https:' ||
                          location.hostname === 'signalsense.trade' ||
                          location.hostname === 'www.signalsense.trade';

      if (isProduction) {
        // Disable right-click context menu
        document.addEventListener('contextmenu', function(e) {
          e.preventDefault();
          return false;
        });

        // Disable keyboard shortcuts for devtools
        document.addEventListener('keydown', function(e) {
          // F12
          if (e.key === 'F12') {
            e.preventDefault();
            return false;
          }
          // Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+Shift+C
          if (e.ctrlKey && e.shiftKey && ['I', 'J', 'C'].includes(e.key.toUpperCase())) {
            e.preventDefault();
            return false;
          }
          // Ctrl+U (view source)
          if (e.ctrlKey && e.key.toUpperCase() === 'U') {
            e.preventDefault();
            return false;
          }
        });

        // Disable console methods
        const noop = function() {};
        const methods = ['log', 'debug', 'info', 'warn', 'error', 'table', 'trace', 'dir', 'dirxml', 'group', 'groupEnd', 'time', 'timeEnd', 'assert', 'count', 'clear'];
        methods.forEach(function(method) {
          console[method] = noop;
        });

        // DevTools detection via debugger timing
        let devtoolsOpen = false;
        const threshold = 160;

        setInterval(function() {
          const start = performance.now();
          debugger;
          const end = performance.now();
          if (end - start > threshold) {
            if (!devtoolsOpen) {
              devtoolsOpen = true;
              document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0a0e17;color:#f85149;font-family:sans-serif;font-size:24px;text-align:center;padding:20px;">Developer tools detected.<br>Please close them to continue.</div>';
            }
          }
        }, 1000);

        // Disable text selection on sensitive elements
        document.addEventListener('DOMContentLoaded', function() {
          document.body.style.userSelect = 'none';
          document.body.style.webkitUserSelect = 'none';
        });
      }
    })();
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0e17;
      color: #e1e5eb;
      min-height: 100vh;
    }

    /* Header */
    .header {
      background: linear-gradient(135deg, #1a1f2e 0%, #0d1117 100%);
      border-bottom: 1px solid #30363d;
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo h1 {
      font-size: 20px;
      font-weight: 700;
      background: linear-gradient(135deg, #00d4aa 0%, #00a8cc 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .status-bar {
      display: flex;
      align-items: center;
      gap: 20px;
      font-size: 13px;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ef4444;
    }

    .status-dot.connected {
      background: #22c55e;
      box-shadow: 0 0 8px #22c55e;
    }

    /* Filter Bar */
    .filter-bar {
      background: #161b22;
      padding: 10px 20px;
      display: flex;
      align-items: center;
      gap: 15px;
      border-bottom: 1px solid #21262d;
      flex-wrap: wrap;
    }

    .filter-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .filter-label {
      font-size: 12px;
      color: #8b949e;
    }

    .filter-select, .filter-input {
      background: #0d1117;
      border: 1px solid #30363d;
      color: #e1e5eb;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
    }

    .filter-btn {
      background: #238636;
      border: none;
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .filter-btn:hover {
      background: #2ea043;
    }

    .filter-btn.preset {
      background: #21262d;
    }

    .filter-btn.preset:hover {
      background: #30363d;
    }

    .filter-btn.preset.active {
      background: #1f6feb;
    }

    /* Main Grid Layout */
    .main-container {
      padding: 15px;
      display: grid;
      gap: 15px;
    }

    /* Smart Signals Section - Top Priority */
    .smart-signals-section {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
    }

    /* Regular Panels Grid */
    .panels-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
    }

    /* Panel Styles */
    .panel {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 10px;
      overflow: hidden;
    }

    .panel-header {
      padding: 12px 15px;
      border-bottom: 1px solid #21262d;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-title {
      font-size: 13px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .panel-badge {
      background: #30363d;
      color: #8b949e;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
    }

    .panel-content {
      padding: 10px;
      max-height: 300px;
      overflow-y: auto;
    }

    /* Collapsible Panel Styles */
    .panel-header {
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }

    .panel-header:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .collapse-toggle {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #8b949e;
      transition: transform 0.3s ease;
      flex-shrink: 0;
      margin-left: 8px;
    }

    .collapse-toggle svg {
      width: 12px;
      height: 12px;
    }

    .panel.collapsed .collapse-toggle {
      transform: rotate(-90deg);
    }

    .panel.collapsed .panel-content {
      display: none;
    }

    .panel-header-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .panel-header-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* Section Collapsible Styles */
    .section-collapsible {
      cursor: pointer;
      user-select: none;
    }

    .section-collapsible:hover {
      opacity: 0.9;
    }

    .section-collapsible .collapse-toggle {
      display: inline-flex;
      margin-left: 8px;
    }

    .collapsible-content {
      transition: max-height 0.3s ease, opacity 0.3s ease;
      overflow: hidden;
    }

    .collapsible-content.collapsed {
      max-height: 0 !important;
      opacity: 0;
      padding: 0 !important;
      margin: 0 !important;
    }

    /* Performance Section Collapsible */
    .performance-section .performance-header {
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
      border-radius: 8px;
      margin: -8px;
      padding: 8px;
    }

    .performance-section .performance-header:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .performance-section.collapsed .performance-grid,
    .performance-section.collapsed .type-performance,
    .performance-section.collapsed .recent-signals {
      display: none;
    }

    .performance-section.collapsed {
      padding-bottom: 8px;
    }

    /* Top Picks Section Collapsible */
    .top-picks-section .top-picks-header {
      cursor: pointer;
      user-select: none;
    }

    .top-picks-section.collapsed .top-picks-grid {
      display: none;
    }

    /* Smart Signals Section Collapsible */
    .smart-signals-section.collapsed {
      display: none;
    }

    /* Panels Grid Collapsible */
    .panels-grid.collapsed {
      display: none;
    }

    /* Smart Signal Panel - Special Styling */
    .panel.smart-long {
      border-color: #238636;
      background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
    }

    .panel.smart-long .panel-header {
      background: rgba(35, 134, 54, 0.1);
    }

    .panel.smart-short {
      border-color: #da3633;
      background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
    }

    .panel.smart-short .panel-header {
      background: rgba(218, 54, 51, 0.1);
    }

    .panel.smart-reversal {
      border-color: #a371f7;
      background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
    }

    .panel.smart-reversal .panel-header {
      background: rgba(163, 113, 247, 0.1);
    }

    /* Item Styles */
    .item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      border-radius: 6px;
      margin-bottom: 6px;
      background: #0d1117;
      transition: background 0.2s;
      cursor: pointer;
    }

    .item:hover {
      background: #21262d;
    }

    .item:last-child {
      margin-bottom: 0;
    }

    .item-left {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .item-symbol {
      font-weight: 600;
      font-size: 13px;
      color: #e1e5eb;
    }

    .item-meta {
      font-size: 11px;
      color: #8b949e;
    }

    .item-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
    }

    .item-value {
      font-weight: 600;
      font-size: 13px;
      color: #e1e5eb;
    }

    .item-sub {
      font-size: 10px;
      color: #8b949e;
    }

    /* Smart Signal Item - Special */
    .smart-item {
      padding: 10px 12px;
      background: #0d1117;
      border-radius: 8px;
      margin-bottom: 8px;
      border: 1px solid #30363d;
    }

    .smart-item:hover {
      border-color: #484f58;
    }

    .smart-item-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 6px;
    }

    .smart-item-symbol {
      font-weight: 700;
      font-size: 14px;
      color: #e1e5eb;
    }

    .smart-item-direction {
      font-size: 11px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 4px;
    }

    .smart-item-direction.long {
      background: rgba(63, 185, 80, 0.2);
      color: #3fb950;
    }

    .smart-item-direction.short {
      background: rgba(248, 81, 73, 0.2);
      color: #f85149;
    }

    .smart-item-confidence {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    .confidence-bar {
      flex: 1;
      height: 6px;
      background: #21262d;
      border-radius: 3px;
      overflow: hidden;
    }

    .confidence-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.3s;
    }

    .confidence-fill.high {
      background: linear-gradient(90deg, #238636, #3fb950);
    }

    .confidence-fill.medium {
      background: linear-gradient(90deg, #9e6a03, #d29922);
    }

    .confidence-fill.low {
      background: linear-gradient(90deg, #da3633, #f85149);
    }

    .confidence-text {
      font-size: 12px;
      font-weight: 600;
      min-width: 35px;
      text-align: right;
    }

    .smart-item-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 6px;
    }

    .meta-tag {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      background: #21262d;
      color: #8b949e;
    }

    .meta-tag.entry-type {
      background: rgba(56, 139, 253, 0.2);
      color: #58a6ff;
    }

    .meta-tag.risk-low {
      background: rgba(63, 185, 80, 0.2);
      color: #3fb950;
    }

    .meta-tag.risk-medium {
      background: rgba(210, 153, 34, 0.2);
      color: #d29922;
    }

    .meta-tag.risk-high {
      background: rgba(248, 81, 73, 0.2);
      color: #f85149;
    }

    .smart-item-reasons {
      font-size: 11px;
      color: #8b949e;
      line-height: 1.4;
    }

    /* Reversal Signal Item */
    .reversal-item {
      padding: 10px 12px;
      background: #0d1117;
      border-radius: 8px;
      margin-bottom: 8px;
      border: 1px solid #30363d;
    }

    .reversal-item:hover {
      border-color: #484f58;
    }

    .reversal-triggers {
      margin-top: 6px;
      padding-left: 10px;
      border-left: 2px solid #30363d;
    }

    .reversal-trigger {
      font-size: 11px;
      color: #8b949e;
      margin-bottom: 3px;
    }

    .reversal-levels {
      display: flex;
      gap: 15px;
      margin-top: 8px;
      font-size: 11px;
    }

    .reversal-level {
      display: flex;
      flex-direction: column;
    }

    .reversal-level-label {
      color: #8b949e;
      font-size: 10px;
    }

    .reversal-level-value {
      font-weight: 600;
    }

    .reversal-level-value.target {
      color: #3fb950;
    }

    .reversal-level-value.stop {
      color: #f85149;
    }

    /* Section Headers */
    .section-header {
      padding: 10px 20px;
      background: #0d1117;
      border-bottom: 1px solid #21262d;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .section-title {
      font-size: 14px;
      font-weight: 600;
      color: #e1e5eb;
    }

    .section-icon {
      font-size: 16px;
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 20px;
      color: #8b949e;
      font-size: 12px;
    }

    /* Directional Coloring */
    .item-value.positive {
      color: #3fb950;
    }

    .item-value.negative {
      color: #f85149;
    }

    .item-symbol.positive {
      color: #3fb950;
    }

    .item-symbol.negative {
      color: #f85149;
    }

    /* Compact View Mode */
    .compact-view .smart-item {
      padding: 6px 10px;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .compact-view .smart-item-header {
      margin-bottom: 0;
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .compact-view .smart-item-confidence {
      margin-bottom: 0;
      flex: 1;
      max-width: 120px;
    }

    .compact-view .smart-item-meta {
      margin-bottom: 0;
      flex: 0 0 auto;
    }

    .compact-view .smart-item-reasons {
      display: none;
    }

    .compact-view .reversal-item {
      padding: 6px 10px;
      margin-bottom: 4px;
    }

    .compact-view .reversal-triggers {
      display: none;
    }

    .compact-view .reversal-levels {
      margin-top: 4px;
    }

    .compact-view .item {
      padding: 5px 8px;
      margin-bottom: 3px;
    }

    .compact-view .panel-content {
      max-height: 400px;
    }

    /* View toggle active state */
    .view-toggle.active {
      background: #1f6feb;
    }

    /* Sentiment Bar */
    .sentiment-bar {
      background: linear-gradient(135deg, #1a1f2e 0%, #0d1117 100%);
      border-bottom: 1px solid #30363d;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 15px;
    }

    .sentiment-section {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .sentiment-gauge {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .sentiment-label {
      font-size: 12px;
      color: #8b949e;
    }

    .sentiment-value {
      font-size: 14px;
      font-weight: 600;
      padding: 4px 10px;
      border-radius: 4px;
    }

    .sentiment-value.extreme-fear { background: rgba(248, 81, 73, 0.2); color: #f85149; }
    .sentiment-value.fear { background: rgba(240, 136, 62, 0.2); color: #f0883e; }
    .sentiment-value.neutral { background: rgba(139, 148, 158, 0.2); color: #8b949e; }
    .sentiment-value.greed { background: rgba(210, 153, 34, 0.2); color: #d29922; }
    .sentiment-value.extreme-greed { background: rgba(63, 185, 80, 0.2); color: #3fb950; }

    .sentiment-meter {
      width: 150px;
      height: 8px;
      background: linear-gradient(90deg, #f85149, #f0883e, #8b949e, #d29922, #3fb950);
      border-radius: 4px;
      position: relative;
    }

    .sentiment-needle {
      position: absolute;
      width: 4px;
      height: 12px;
      background: #fff;
      border-radius: 2px;
      top: -2px;
      transform: translateX(-50%);
      box-shadow: 0 0 4px rgba(0,0,0,0.5);
    }

    .stats-section {
      display: flex;
      gap: 20px;
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .stat-value {
      font-size: 16px;
      font-weight: 700;
    }

    .stat-value.positive { color: #3fb950; }
    .stat-value.negative { color: #f85149; }

    .stat-label {
      font-size: 10px;
      color: #8b949e;
      text-transform: uppercase;
    }

    /* Notification Toast */
    .notification-container {
      position: fixed;
      top: 70px;
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 350px;
    }

    .notification-toast {
      background: #1a1f2e;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 12px 15px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      animation: slideIn 0.3s ease;
      cursor: pointer;
    }

    .notification-toast:hover {
      background: #21262d;
    }

    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    .notification-toast.critical { border-left: 4px solid #f85149; }
    .notification-toast.high { border-left: 4px solid #d29922; }
    .notification-toast.medium { border-left: 4px solid #58a6ff; }
    .notification-toast.low { border-left: 4px solid #8b949e; }

    .notification-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    .notification-title {
      font-size: 13px;
      font-weight: 600;
      color: #e1e5eb;
    }

    .notification-direction {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
    }

    .notification-direction.long { background: rgba(63, 185, 80, 0.2); color: #3fb950; }
    .notification-direction.short { background: rgba(248, 81, 73, 0.2); color: #f85149; }

    .notification-message {
      font-size: 11px;
      color: #8b949e;
    }

    /* Entry Signal Item */
    .entry-item {
      padding: 8px 10px;
      background: #0d1117;
      border-radius: 6px;
      margin-bottom: 6px;
      cursor: pointer;
    }

    .entry-item:hover {
      background: #21262d;
    }

    .entry-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    .entry-symbol {
      font-weight: 600;
      font-size: 13px;
    }

    .entry-type {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(56, 139, 253, 0.2);
      color: #58a6ff;
    }

    .entry-levels {
      display: flex;
      gap: 12px;
      font-size: 10px;
    }

    .entry-level {
      display: flex;
      gap: 4px;
    }

    .entry-level-label { color: #8b949e; }
    .entry-level-value.entry { color: #e1e5eb; }
    .entry-level-value.sl { color: #f85149; }
    .entry-level-value.tp { color: #3fb950; }

    .entry-rr {
      font-size: 11px;
      color: #58a6ff;
      margin-top: 4px;
    }

    /* Top Picks Section */
    .top-picks-section {
      background: linear-gradient(135deg, #1a1f2e 0%, #0d1117 100%);
      border: 2px solid #d29922;
      border-radius: 12px;
      margin-bottom: 15px;
      overflow: hidden;
    }

    .top-picks-header {
      background: linear-gradient(90deg, rgba(210, 153, 34, 0.2), transparent);
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #30363d;
    }

    .top-picks-title {
      font-size: 16px;
      font-weight: 700;
      color: #d29922;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .top-picks-subtitle {
      font-size: 11px;
      color: #8b949e;
    }

    .top-picks-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      padding: 15px;
    }

    .picks-column {
      background: #0d1117;
      border-radius: 8px;
      padding: 10px;
    }

    .picks-column.long {
      border: 1px solid rgba(63, 185, 80, 0.3);
    }

    .picks-column.short {
      border: 1px solid rgba(248, 81, 73, 0.3);
    }

    .picks-column-header {
      font-size: 13px;
      font-weight: 600;
      padding: 8px 10px;
      border-radius: 6px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .picks-column.long .picks-column-header {
      background: rgba(63, 185, 80, 0.15);
      color: #3fb950;
    }

    .picks-column.short .picks-column-header {
      background: rgba(248, 81, 73, 0.15);
      color: #f85149;
    }

    .pick-item {
      background: #161b22;
      border-radius: 8px;
      padding: 10px 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid #30363d;
    }

    .pick-item:hover {
      border-color: #d29922;
      transform: translateX(2px);
    }

    .pick-item:last-child {
      margin-bottom: 0;
    }

    .pick-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      gap: 8px;
    }

    .pick-header-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .pick-sparkline {
      width: 70px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      overflow: hidden;
      flex-shrink: 0;
    }

    .pick-sparkline .sparkline {
      width: 100%;
      height: 100%;
    }

    .pick-symbol {
      font-weight: 700;
      font-size: 14px;
    }

    .pick-symbol.long { color: #3fb950; }
    .pick-symbol.short { color: #f85149; }

    .pick-score {
      font-size: 12px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 4px;
      background: rgba(210, 153, 34, 0.2);
      color: #d29922;
    }

    .pick-funding {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 6px;
      font-size: 11px;
    }

    .pick-funding-badge {
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
    }

    .pick-funding-badge.earn {
      background: rgba(63, 185, 80, 0.2);
      color: #3fb950;
    }

    .pick-funding-badge.pay {
      background: rgba(248, 81, 73, 0.2);
      color: #f85149;
    }

    .pick-funding-rate {
      color: #8b949e;
    }

    .pick-meta {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 6px;
    }

    .pick-tag {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      background: #21262d;
      color: #8b949e;
    }

    .pick-tag.momentum-strong { background: rgba(63, 185, 80, 0.2); color: #3fb950; }
    .pick-tag.momentum-moderate { background: rgba(210, 153, 34, 0.2); color: #d29922; }
    .pick-tag.urgency-now { background: rgba(248, 81, 73, 0.2); color: #f85149; }
    .pick-tag.urgency-wait { background: rgba(56, 139, 253, 0.2); color: #58a6ff; }

    .pick-levels {
      display: flex;
      gap: 12px;
      font-size: 10px;
      padding-top: 6px;
      border-top: 1px solid #21262d;
    }

    .pick-level {
      display: flex;
      gap: 4px;
    }

    .pick-level-label { color: #8b949e; }
    .pick-level-value.sl { color: #f85149; }
    .pick-level-value.tp { color: #3fb950; }
    .pick-level-value.lev { color: #58a6ff; }

    .pick-reasons {
      font-size: 10px;
      color: #8b949e;
      margin-top: 6px;
      line-height: 1.4;
    }

    /* Compact mode adjustments for picks */
    .compact-view .pick-item {
      padding: 6px 10px;
      margin-bottom: 4px;
    }

    .compact-view .pick-reasons {
      display: none;
    }

    .compact-view .pick-meta {
      margin-bottom: 4px;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: #0d1117;
    }

    ::-webkit-scrollbar-thumb {
      background: #30363d;
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #484f58;
    }

    /* Skeleton Loader Styles */
    .skeleton {
      background: linear-gradient(90deg, #21262d 25%, #30363d 50%, #21262d 75%);
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s infinite;
      border-radius: 4px;
    }

    @keyframes skeleton-loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .skeleton-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      margin-bottom: 6px;
      background: #0d1117;
      border-radius: 6px;
    }

    .skeleton-item .skeleton-symbol {
      width: 80px;
      height: 14px;
    }

    .skeleton-item .skeleton-value {
      width: 60px;
      height: 14px;
    }

    .skeleton-smart-item {
      padding: 10px 12px;
      background: #0d1117;
      border-radius: 8px;
      margin-bottom: 8px;
      border: 1px solid #30363d;
    }

    .skeleton-smart-item .skeleton-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .skeleton-smart-item .skeleton-symbol {
      width: 100px;
      height: 16px;
    }

    .skeleton-smart-item .skeleton-badge {
      width: 50px;
      height: 16px;
    }

    .skeleton-smart-item .skeleton-bar {
      width: 100%;
      height: 6px;
      margin-bottom: 8px;
    }

    .skeleton-smart-item .skeleton-meta {
      display: flex;
      gap: 6px;
    }

    .skeleton-smart-item .skeleton-tag {
      width: 60px;
      height: 18px;
    }

    /* Drag and Drop Styles */
    .panel.draggable {
      cursor: grab;
    }

    .panel.draggable:active {
      cursor: grabbing;
    }

    .panel.dragging {
      opacity: 0.5;
      transform: scale(1.02);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      z-index: 1000;
    }

    .panel.drag-over {
      border: 2px dashed #d29922;
      background: rgba(210, 153, 34, 0.1);
    }

    .panel-header.drag-handle {
      cursor: grab;
    }

    .panel-header.drag-handle:active {
      cursor: grabbing;
    }

    .drag-placeholder {
      border: 2px dashed #30363d;
      background: rgba(48, 54, 61, 0.3);
      border-radius: 10px;
      min-height: 200px;
    }

    /* Layout customization indicator */
    .layout-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .reset-layout-btn {
      background: #21262d;
      border: 1px solid #30363d;
      color: #8b949e;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .reset-layout-btn:hover {
      background: #30363d;
      color: #e1e5eb;
    }

    .layout-indicator {
      font-size: 11px;
      color: #8b949e;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .layout-indicator.modified {
      color: #d29922;
    }

    /* ============================================ */
    /* CONNECTION STATUS OVERLAY                   */
    /* ============================================ */
    .connection-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10, 14, 23, 0.95);
      z-index: 9999;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      backdrop-filter: blur(5px);
    }

    .connection-overlay.visible {
      display: flex;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .connection-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid #30363d;
      border-top-color: #d29922;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .connection-message {
      font-size: 20px;
      font-weight: 600;
      color: #e1e5eb;
    }

    .connection-submessage {
      font-size: 14px;
      color: #8b949e;
      text-align: center;
      max-width: 300px;
    }

    .connection-retry-count {
      font-size: 12px;
      color: #8b949e;
      padding: 6px 12px;
      background: #21262d;
      border-radius: 20px;
    }

    /* Connection Status Banner (top bar) */
    .connection-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 8px 20px;
      background: linear-gradient(90deg, #da3633, #f85149);
      color: white;
      font-size: 13px;
      font-weight: 500;
      text-align: center;
      z-index: 1001;
      display: none;
      align-items: center;
      justify-content: center;
      gap: 10px;
      transform: translateY(-100%);
      transition: transform 0.3s ease;
    }

    .connection-banner.visible {
      display: flex;
      transform: translateY(0);
    }

    .connection-banner.reconnecting {
      background: linear-gradient(90deg, #9e6a03, #d29922);
    }

    .connection-banner.connected {
      background: linear-gradient(90deg, #238636, #3fb950);
    }

    .banner-spinner {
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* Pulse animation for status dot */
    .status-dot.disconnected {
      background: #f85149;
      animation: pulse-red 1.5s ease infinite;
    }

    .status-dot.reconnecting {
      background: #d29922;
      animation: pulse-yellow 1s ease infinite;
    }

    @keyframes pulse-red {
      0%, 100% { box-shadow: 0 0 0 0 rgba(248, 81, 73, 0.7); }
      50% { box-shadow: 0 0 0 8px rgba(248, 81, 73, 0); }
    }

    @keyframes pulse-yellow {
      0%, 100% { box-shadow: 0 0 0 0 rgba(210, 153, 34, 0.7); }
      50% { box-shadow: 0 0 0 8px rgba(210, 153, 34, 0); }
    }

    @keyframes pulse-green {
      0%, 100% { box-shadow: 0 0 8px rgba(34, 197, 94, 0.5); }
      50% { box-shadow: 0 0 15px rgba(34, 197, 94, 0.8); }
    }

    .status-dot.connected {
      animation: pulse-green 2s ease infinite;
    }

    /* ============================================ */
    /* MOBILE RESPONSIVE STYLES                    */
    /* ============================================ */

    /* Large Desktop (1600px and below) */
    @media (max-width: 1600px) {
      .smart-signals-section {
        grid-template-columns: repeat(2, 1fr);
      }
      .panels-grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    /* Desktop (1200px and below) */
    @media (max-width: 1200px) {
      .smart-signals-section {
        grid-template-columns: 1fr;
      }
      .panels-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      .top-picks-grid {
        grid-template-columns: 1fr;
      }
      .sentiment-bar {
        flex-direction: column;
        gap: 10px;
      }
      .stats-section {
        flex-wrap: wrap;
        justify-content: center;
      }
    }

    /* Tablet (1024px and below) */
    @media (max-width: 1024px) {
      .header {
        flex-direction: column;
        gap: 10px;
        padding: 10px 15px;
      }
      .logo {
        flex-direction: column;
        text-align: center;
        gap: 4px;
      }
      .logo h1 {
        font-size: 18px;
      }
      .status-bar {
        width: 100%;
        justify-content: center;
        flex-wrap: wrap;
      }
      .filter-bar {
        padding: 10px 15px;
        justify-content: center;
      }
      .filter-group {
        flex-wrap: wrap;
        justify-content: center;
      }
      .layout-controls {
        width: 100%;
        justify-content: center;
        margin-top: 5px;
      }
      .main-container {
        padding: 10px;
      }
      .panel-content {
        max-height: 250px;
      }
    }

    /* Mobile Landscape / Small Tablet (768px and below) */
    @media (max-width: 768px) {
      .panels-grid {
        grid-template-columns: 1fr;
      }
      .header {
        position: relative;
        top: auto;
      }
      .logo h1 {
        font-size: 16px;
      }
      .logo span {
        font-size: 10px !important;
      }
      .filter-bar {
        gap: 8px;
      }
      .filter-select, .filter-input {
        padding: 8px 10px;
        font-size: 14px;
      }
      .filter-btn {
        padding: 8px 12px;
        font-size: 12px;
      }
      .sentiment-bar {
        padding: 10px 15px;
      }
      .sentiment-meter {
        width: 120px;
      }
      .sentiment-section {
        flex-wrap: wrap;
        justify-content: center;
      }
      .top-picks-section {
        margin: 0 0 10px 0;
      }
      .top-picks-header {
        flex-direction: column;
        gap: 5px;
        text-align: center;
      }
      .panel-header {
        padding: 10px 12px;
      }
      .panel-title {
        font-size: 12px;
      }
      .notification-container {
        left: 10px;
        right: 10px;
        max-width: none;
      }
      .smart-item {
        padding: 8px 10px;
      }
      .smart-item-symbol {
        font-size: 13px;
      }
      .pick-item {
        padding: 8px 10px;
      }
      .pick-symbol {
        font-size: 13px;
      }
      /* Disable drag on mobile */
      .panel {
        cursor: default !important;
      }
      .panel[draggable="true"] {
        cursor: default !important;
      }
      .layout-indicator {
        display: none;
      }
    }

    /* Mobile Portrait (480px and below) */
    @media (max-width: 480px) {
      body {
        font-size: 14px;
      }
      .header {
        padding: 8px 10px;
      }
      .logo h1 {
        font-size: 14px;
      }
      .status-bar {
        font-size: 11px;
        gap: 10px;
      }
      .filter-bar {
        padding: 8px 10px;
      }
      .filter-label {
        display: none;
      }
      .filter-select, .filter-input {
        flex: 1;
        min-width: 0;
        font-size: 13px;
      }
      .filter-btn {
        font-size: 11px;
        padding: 6px 10px;
      }
      .main-container {
        padding: 8px;
        gap: 10px;
      }
      .panel {
        border-radius: 8px;
      }
      .panel-content {
        padding: 8px;
        max-height: 220px;
      }
      .item {
        padding: 6px 8px;
      }
      .item-symbol {
        font-size: 12px;
      }
      .item-value {
        font-size: 12px;
      }
      .smart-item-header {
        flex-wrap: wrap;
        gap: 4px;
      }
      .smart-item-meta {
        gap: 4px;
      }
      .meta-tag {
        font-size: 9px;
        padding: 2px 4px;
      }
      .sentiment-bar {
        padding: 8px 10px;
      }
      .sentiment-gauge {
        flex-wrap: wrap;
        justify-content: center;
      }
      .sentiment-meter {
        width: 100px;
      }
      .stat-item {
        min-width: 60px;
      }
      .stat-value {
        font-size: 14px;
      }
      .stat-label {
        font-size: 9px;
      }
      .top-picks-header {
        padding: 10px 15px;
      }
      .top-picks-title {
        font-size: 14px;
      }
      .picks-column {
        padding: 8px;
      }
      .picks-column-header {
        font-size: 12px;
        padding: 6px 8px;
      }
      .section-header {
        padding: 8px 10px;
      }
      .section-title {
        font-size: 12px;
      }
      .connection-message {
        font-size: 16px;
      }
      .connection-submessage {
        font-size: 12px;
        padding: 0 20px;
      }
    }

    /* Extra small devices (360px and below) */
    @media (max-width: 360px) {
      .logo h1 {
        font-size: 12px;
      }
      .filter-group {
        width: 100%;
      }
      .filter-select {
        width: 100%;
      }
      .status-bar > div {
        font-size: 10px;
      }
    }

    /* Touch-friendly improvements */
    @media (hover: none) and (pointer: coarse) {
      .item {
        padding: 10px 12px;
        margin-bottom: 8px;
      }
      .smart-item {
        padding: 12px;
        margin-bottom: 10px;
      }
      .filter-btn {
        min-height: 44px;
        min-width: 44px;
      }
      .filter-select, .filter-input {
        min-height: 44px;
      }
      .pick-item {
        padding: 12px;
        margin-bottom: 10px;
      }
      .notification-toast {
        padding: 14px 16px;
      }
    }

    /* Landscape orientation adjustments */
    @media (max-height: 500px) and (orientation: landscape) {
      .connection-overlay {
        gap: 10px;
      }
      .connection-spinner {
        width: 40px;
        height: 40px;
      }
      .connection-message {
        font-size: 16px;
      }
    }

    /* ====== SPARKLINE CHARTS ====== */
    .sparkline-container {
      width: 60px;
      height: 24px;
      margin-left: 8px;
      flex-shrink: 0;
    }

    .sparkline {
      width: 100%;
      height: 100%;
    }

    .sparkline-path {
      fill: none;
      stroke-width: 1.5;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .sparkline-path.up {
      stroke: #3fb950;
    }

    .sparkline-path.down {
      stroke: #f85149;
    }

    .sparkline-path.neutral {
      stroke: #8b949e;
    }

    .sparkline-dot {
      r: 2;
    }

    .sparkline-dot.up {
      fill: #3fb950;
    }

    .sparkline-dot.down {
      fill: #f85149;
    }

    .sparkline-dot.neutral {
      fill: #8b949e;
    }

    /* Item with sparkline */
    .item-with-sparkline {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      border-radius: 6px;
      margin-bottom: 6px;
      background: #0d1117;
      transition: background 0.2s;
      cursor: pointer;
    }

    .item-with-sparkline:hover {
      background: #21262d;
    }

    .item-main {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex: 1;
      min-width: 0;
    }

    /* ====== PERFORMANCE TRACKING PANEL ====== */
    .performance-section {
      background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 15px;
    }

    .performance-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .performance-title {
      font-size: 14px;
      font-weight: 600;
      color: #e1e5eb;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .performance-subtitle {
      font-size: 11px;
      color: #8b949e;
    }

    .performance-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 16px;
      margin-bottom: 16px;
    }

    .performance-stat {
      background: #0d1117;
      border-radius: 8px;
      padding: 12px;
      text-align: center;
    }

    .performance-stat-value {
      font-size: 20px;
      font-weight: 700;
      color: #e1e5eb;
      margin-bottom: 4px;
    }

    .performance-stat-value.positive {
      color: #3fb950;
    }

    .performance-stat-value.negative {
      color: #f85149;
    }

    .performance-stat-value.pending {
      color: #d29922;
    }

    .performance-stat-label {
      font-size: 10px;
      color: #8b949e;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Recent Signals Table */
    .recent-signals {
      margin-top: 16px;
    }

    .recent-signals-header {
      font-size: 12px;
      font-weight: 600;
      color: #8b949e;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .signals-table {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .signal-row {
      display: grid;
      grid-template-columns: 100px 80px 70px 80px 70px 80px auto;
      gap: 8px;
      align-items: center;
      padding: 8px 10px;
      background: #0d1117;
      border-radius: 6px;
      font-size: 12px;
    }

    .signal-sparkline {
      height: 24px;
      display: flex;
      align-items: center;
    }

    .signal-sparkline .sparkline {
      width: 100%;
      height: 100%;
    }

    .signal-row:hover {
      background: #21262d;
      cursor: pointer;
    }

    .signal-symbol {
      font-weight: 600;
      color: #e1e5eb;
    }

    .signal-direction {
      font-weight: 600;
      padding: 2px 6px;
      border-radius: 4px;
      text-align: center;
      font-size: 10px;
    }

    .signal-direction.long {
      background: rgba(63, 185, 80, 0.2);
      color: #3fb950;
    }

    .signal-direction.short {
      background: rgba(248, 81, 73, 0.2);
      color: #f85149;
    }

    .signal-entry {
      color: #8b949e;
    }

    .signal-pnl {
      font-weight: 600;
    }

    .signal-pnl.positive {
      color: #3fb950;
    }

    .signal-pnl.negative {
      color: #f85149;
    }

    .signal-outcome {
      padding: 2px 8px;
      border-radius: 4px;
      text-align: center;
      font-size: 10px;
      font-weight: 600;
    }

    .signal-outcome.win {
      background: rgba(63, 185, 80, 0.2);
      color: #3fb950;
    }

    .signal-outcome.loss {
      background: rgba(248, 81, 73, 0.2);
      color: #f85149;
    }

    .signal-outcome.pending {
      background: rgba(139, 148, 158, 0.2);
      color: #8b949e;
    }

    .signal-time {
      color: #8b949e;
      font-size: 10px;
    }

    /* Performance by Type */
    .type-performance {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    .type-stat {
      display: flex;
      align-items: center;
      gap: 6px;
      background: #0d1117;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 11px;
    }

    .type-stat-label {
      color: #8b949e;
    }

    .type-stat-value {
      font-weight: 600;
    }

    .type-stat-value.positive {
      color: #3fb950;
    }

    .type-stat-value.negative {
      color: #f85149;
    }

    /* Performance responsive */
    @media (max-width: 1200px) {
      .performance-grid {
        grid-template-columns: repeat(3, 1fr);
      }
      .signal-row {
        grid-template-columns: 80px 70px 60px 70px 60px 60px auto;
        font-size: 11px;
      }
    }

    @media (max-width: 768px) {
      .performance-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      .signal-row {
        grid-template-columns: 1fr 60px 1fr;
        gap: 4px;
      }
      .signal-entry, .signal-time {
        display: none;
      }
      .signal-sparkline {
        height: 20px;
      }
    }

    @media (max-width: 480px) {
      .performance-stat {
        padding: 8px;
      }
      .performance-stat-value {
        font-size: 16px;
      }
    }

    /* ML Status Badge Styles */
    .ml-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 6px;
      background: rgba(30, 30, 45, 0.7);
      border: 1px solid #30363d;
    }

    .ml-status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #6e7681;
    }

    .ml-status-dot.active {
      background: #a371f7;
      box-shadow: 0 0 8px #a371f7;
    }

    .ml-status-dot.inactive {
      background: #6e7681;
    }

    .ml-status-label {
      color: #8b949e;
    }

    .ml-status-value {
      color: #e1e5eb;
      font-weight: 500;
    }

    .ml-version {
      color: #a371f7;
      font-size: 11px;
    }

    /* ML Quality Tier Badges */
    .quality-tier-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .quality-tier-badge.tier-high {
      background: rgba(63, 185, 80, 0.2);
      color: #3fb950;
      border: 1px solid rgba(63, 185, 80, 0.3);
    }

    .quality-tier-badge.tier-medium {
      background: rgba(210, 153, 34, 0.2);
      color: #d29922;
      border: 1px solid rgba(210, 153, 34, 0.3);
    }

    .quality-tier-badge.tier-low {
      background: rgba(240, 136, 62, 0.2);
      color: #f0883e;
      border: 1px solid rgba(240, 136, 62, 0.3);
    }

    .quality-tier-badge.tier-filter {
      background: rgba(248, 81, 73, 0.2);
      color: #f85149;
      border: 1px solid rgba(248, 81, 73, 0.3);
    }

    /* ML Enhanced Signal Card */
    .smart-item.ml-enhanced {
      border-left: 3px solid #a371f7;
    }

    .ml-confidence-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px dashed rgba(139, 148, 158, 0.2);
      font-size: 11px;
    }

    .ml-confidence-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .ml-confidence-label {
      color: #8b949e;
    }

    .ml-confidence-value {
      font-weight: 600;
    }

    .ml-confidence-value.rule {
      color: #58a6ff;
    }

    .ml-confidence-value.ml {
      color: #a371f7;
    }

    .ml-confidence-value.combined {
      color: #3fb950;
    }

    .win-prob {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .win-prob-value {
      font-weight: 600;
    }

    .win-prob-value.high { color: #3fb950; }
    .win-prob-value.medium { color: #d29922; }
    .win-prob-value.low { color: #f0883e; }

    /* ML Model Performance Panel in Performance Section */
    .ml-performance-panel {
      background: rgba(163, 113, 247, 0.05);
      border: 1px solid rgba(163, 113, 247, 0.2);
      border-radius: 8px;
      padding: 12px;
      margin-top: 12px;
    }

    .ml-performance-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .ml-performance-title {
      font-size: 13px;
      font-weight: 600;
      color: #a371f7;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .ml-performance-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
    }

    .ml-stat {
      text-align: center;
    }

    .ml-stat-value {
      font-size: 18px;
      font-weight: 700;
      color: #e1e5eb;
    }

    .ml-stat-label {
      font-size: 11px;
      color: #8b949e;
      margin-top: 2px;
    }

    .ml-stat-value.positive { color: #3fb950; }
    .ml-stat-value.negative { color: #f85149; }
    .ml-stat-value.ml-color { color: #a371f7; }

    /* ML Feature importance mini display */
    .feature-importance {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 8px;
    }

    .feature-tag {
      background: rgba(88, 166, 255, 0.1);
      color: #58a6ff;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
    }

    @media (max-width: 1200px) {
      .ml-performance-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 768px) {
      .ml-status {
        display: none;
      }
    }

    /* Market Hours Indicator */
    .market-hours-bar {
      background: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
      border-bottom: 1px solid #21262d;
      padding: 8px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      overflow-x: auto;
      scrollbar-width: thin;
      scrollbar-color: #30363d #161b22;
    }

    .market-hours-bar::-webkit-scrollbar {
      height: 4px;
    }

    .market-hours-bar::-webkit-scrollbar-track {
      background: #161b22;
    }

    .market-hours-bar::-webkit-scrollbar-thumb {
      background: #30363d;
      border-radius: 2px;
    }

    .market-hours-label {
      font-size: 11px;
      color: #8b949e;
      white-space: nowrap;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .market-hours-label svg {
      width: 14px;
      height: 14px;
      fill: #8b949e;
    }

    .market-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: rgba(30, 30, 45, 0.5);
      border: 1px solid #30363d;
      border-radius: 6px;
      white-space: nowrap;
      transition: all 0.3s ease;
    }

    .market-item:hover {
      border-color: #58a6ff;
      background: rgba(88, 166, 255, 0.1);
    }

    .market-item.open {
      border-color: rgba(63, 185, 80, 0.4);
      background: rgba(63, 185, 80, 0.1);
    }

    .market-item.closed {
      border-color: #30363d;
      background: rgba(30, 30, 45, 0.3);
      opacity: 0.7;
    }

    .market-flag {
      font-size: 16px;
      line-height: 1;
    }

    .market-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .market-name {
      font-size: 11px;
      font-weight: 600;
      color: #e1e5eb;
    }

    .market-status {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 10px;
    }

    .market-status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }

    .market-status-dot.open {
      background: #3fb950;
      box-shadow: 0 0 6px #3fb950;
      animation: pulse-green 2s infinite;
    }

    .market-status-dot.closed {
      background: #6e7681;
    }

    @keyframes pulse-green {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .market-status-text {
      color: #8b949e;
    }

    .market-status-text.open {
      color: #3fb950;
    }

    .market-time {
      font-size: 10px;
      color: #58a6ff;
      font-weight: 500;
    }

    .market-local-time {
      font-size: 10px;
      color: #6e7681;
    }

    /* Crypto 24/7 special */
    .market-item.crypto {
      border-color: rgba(210, 153, 34, 0.4);
      background: rgba(210, 153, 34, 0.1);
    }

    .market-item.crypto .market-status-dot {
      background: #d29922;
      box-shadow: 0 0 6px #d29922;
    }

    .market-item.crypto .market-status-text {
      color: #d29922;
    }

    @media (max-width: 768px) {
      .market-hours-bar {
        padding: 6px 10px;
        gap: 8px;
      }

      .market-item {
        padding: 4px 8px;
      }

      .market-name {
        font-size: 10px;
      }

      .market-hours-label {
        display: none;
      }
    }
  </style>
</head>
<body>
  <!-- Connection Status Overlay -->
  <div class="connection-overlay" id="connectionOverlay">
    <div class="connection-spinner"></div>
    <div class="connection-message" id="connectionMessage">Connecting to server...</div>
    <div class="connection-submessage" id="connectionSubmessage">Establishing WebSocket connection to receive real-time data</div>
    <div class="connection-retry-count" id="connectionRetryCount" style="display: none;">Retry attempt: <span id="retryNumber">1</span></div>
  </div>

  <!-- Connection Status Banner -->
  <div class="connection-banner" id="connectionBanner">
    <div class="banner-spinner"></div>
    <span id="bannerMessage">Reconnecting...</span>
  </div>

  <!-- Header -->
  <header class="header">
    <div class="logo">
      <h1>SIGNAL SENSE HUNTER</h1>
      <span style="color: #8b949e; font-size: 12px;">Binance Futures Volatility Hunter</span>
    </div>
    <div class="status-bar">
      <div class="status-indicator">
        <div class="status-dot" id="statusDot"></div>
        <span id="statusText">Connecting...</span>
      </div>
      <div class="ml-status" id="mlStatus">
        <div class="ml-status-dot" id="mlStatusDot"></div>
        <span class="ml-status-label">ML:</span>
        <span class="ml-status-value" id="mlStatusText">Offline</span>
        <span class="ml-version" id="mlVersion"></span>
      </div>
      <div>Symbols: <strong id="symbolCount">0</strong></div>
      <div>Last Update: <span id="lastUpdate">--:--:--</span></div>
    </div>
  </header>

  <!-- Market Hours Bar -->
  <div class="market-hours-bar" id="marketHoursBar">
    <div class="market-hours-label">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"/></svg>
      Markets
    </div>
    <div class="market-item crypto" id="marketCrypto">
      <span class="market-flag"></span>
      <div class="market-info">
        <span class="market-name">Crypto</span>
        <div class="market-status">
          <div class="market-status-dot open"></div>
          <span class="market-status-text open">24/7</span>
        </div>
      </div>
    </div>
    <div class="market-item" id="marketNYSE">
      <span class="market-flag"></span>
      <div class="market-info">
        <span class="market-name">NYSE/NASDAQ</span>
        <div class="market-status">
          <div class="market-status-dot" id="nyseStatusDot"></div>
          <span class="market-status-text" id="nyseStatusText">--</span>
        </div>
      </div>
      <span class="market-time" id="nyseTime">--</span>
    </div>
    <div class="market-item" id="marketLSE">
      <span class="market-flag"></span>
      <div class="market-info">
        <span class="market-name">London</span>
        <div class="market-status">
          <div class="market-status-dot" id="lseStatusDot"></div>
          <span class="market-status-text" id="lseStatusText">--</span>
        </div>
      </div>
      <span class="market-time" id="lseTime">--</span>
    </div>
    <div class="market-item" id="marketTokyo">
      <span class="market-flag"></span>
      <div class="market-info">
        <span class="market-name">Tokyo</span>
        <div class="market-status">
          <div class="market-status-dot" id="tokyoStatusDot"></div>
          <span class="market-status-text" id="tokyoStatusText">--</span>
        </div>
      </div>
      <span class="market-time" id="tokyoTime">--</span>
    </div>
    <div class="market-item" id="marketHongKong">
      <span class="market-flag"></span>
      <div class="market-info">
        <span class="market-name">Hong Kong</span>
        <div class="market-status">
          <div class="market-status-dot" id="hkStatusDot"></div>
          <span class="market-status-text" id="hkStatusText">--</span>
        </div>
      </div>
      <span class="market-time" id="hkTime">--</span>
    </div>
    <div class="market-item" id="marketSydney">
      <span class="market-flag"></span>
      <div class="market-info">
        <span class="market-name">Sydney</span>
        <div class="market-status">
          <div class="market-status-dot" id="sydneyStatusDot"></div>
          <span class="market-status-text" id="sydneyStatusText">--</span>
        </div>
      </div>
      <span class="market-time" id="sydneyTime">--</span>
    </div>
    <div class="market-item" id="marketFrankfurt">
      <span class="market-flag"></span>
      <div class="market-info">
        <span class="market-name">Frankfurt</span>
        <div class="market-status">
          <div class="market-status-dot" id="frankfurtStatusDot"></div>
          <span class="market-status-text" id="frankfurtStatusText">--</span>
        </div>
      </div>
      <span class="market-time" id="frankfurtTime">--</span>
    </div>
  </div>

  <!-- Filter Bar -->
  <div class="filter-bar">
    <div class="filter-group">
      <span class="filter-label">Min Volume:</span>
      <select class="filter-select" id="minVolumeFilter">
        <option value="0" selected>All</option>
        <option value="1000000">$1M+</option>
        <option value="10000000">$10M+</option>
        <option value="50000000">$50M+</option>
        <option value="100000000">$100M+</option>
      </select>
    </div>
    <div class="filter-group">
      <span class="filter-label">Presets:</span>
      <button class="filter-btn preset active" data-preset="all">All</button>
      <button class="filter-btn preset" data-preset="highVolume">High Volume</button>
      <button class="filter-btn preset" data-preset="bigMovers">Big Movers</button>
      <button class="filter-btn preset" data-preset="topTier">Top Tier</button>
    </div>
    <div class="filter-group" style="margin-left: auto;">
      <span class="filter-label">View:</span>
      <button class="filter-btn view-toggle" id="viewToggle" data-view="cards">Compact</button>
    </div>
    <div class="layout-controls">
      <span class="layout-indicator" id="layoutIndicator">
        <span></span> Drag panels to rearrange
      </span>
      <button class="reset-layout-btn" id="resetLayoutBtn" style="display: none;">Reset Layout</button>
    </div>
  </div>

  <!-- Sentiment & Stats Bar -->
  <div class="sentiment-bar">
    <div class="sentiment-section">
      <div class="sentiment-gauge">
        <span class="sentiment-label">Market Sentiment:</span>
        <span class="sentiment-value neutral" id="sentimentValue">NEUTRAL</span>
        <div class="sentiment-meter">
          <div class="sentiment-needle" id="sentimentNeedle" style="left: 50%;"></div>
        </div>
        <span class="sentiment-label" id="sentimentScore">50</span>
      </div>
    </div>
    <div class="stats-section">
      <div class="stat-item">
        <span class="stat-value positive" id="winRate">--%</span>
        <span class="stat-label">Win Rate</span>
      </div>
      <div class="stat-item">
        <span class="stat-value" id="totalSignals">--</span>
        <span class="stat-label">Signals Today</span>
      </div>
      <div class="stat-item">
        <span class="stat-value positive" id="bullishCount">--</span>
        <span class="stat-label">Bullish</span>
      </div>
      <div class="stat-item">
        <span class="stat-value negative" id="bearishCount">--</span>
        <span class="stat-label">Bearish</span>
      </div>
    </div>
  </div>

  <!-- Notification Container -->
  <div class="notification-container" id="notificationContainer"></div>

  <main class="main-container">
    <!-- Performance Tracking Section - Collapsed by default -->
    <div class="performance-section collapsed" id="performanceSection" data-collapsible="performance">
      <div class="performance-header" onclick="toggleCollapse('performanceSection')">
        <div>
          <div class="performance-title">
            <span></span> SIGNAL PERFORMANCE TRACKER
            <span class="collapse-toggle">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </span>
          </div>
          <div class="performance-subtitle">Real-time tracking of signal accuracy and P&L</div>
        </div>
        <div class="performance-subtitle" id="performanceLastUpdate">--</div>
      </div>
      <div class="performance-grid">
        <div class="performance-stat">
          <div class="performance-stat-value" id="perfWinRate">--%</div>
          <div class="performance-stat-label">Win Rate</div>
        </div>
        <div class="performance-stat">
          <div class="performance-stat-value" id="perfTotalSignals">--</div>
          <div class="performance-stat-label">Total Signals</div>
        </div>
        <div class="performance-stat">
          <div class="performance-stat-value positive" id="perfWins">--</div>
          <div class="performance-stat-label">Wins</div>
        </div>
        <div class="performance-stat">
          <div class="performance-stat-value negative" id="perfLosses">--</div>
          <div class="performance-stat-label">Losses</div>
        </div>
        <div class="performance-stat">
          <div class="performance-stat-value pending" id="perfPending">--</div>
          <div class="performance-stat-label">Pending</div>
        </div>
        <div class="performance-stat">
          <div class="performance-stat-value" id="perfAvgWin">--%</div>
          <div class="performance-stat-label">Avg Win</div>
        </div>
        <div class="performance-stat">
          <div class="performance-stat-value" id="perfAvgLoss">--%</div>
          <div class="performance-stat-label">Avg Loss</div>
        </div>
      </div>
      <div class="type-performance" id="typePerformance"></div>
      <div class="recent-signals">
        <div class="recent-signals-header">
          <span>Recent Signals</span>
          <span id="recentSignalsCount">0 signals</span>
        </div>
        <div class="signals-table" id="signalsTable"></div>
      </div>

      <!-- ML Model Performance Panel -->
      <div class="ml-performance-panel" id="mlPerformancePanel">
        <div class="ml-performance-header">
          <div class="ml-performance-title">
            <span></span> ML MODEL PERFORMANCE
          </div>
          <span class="ml-version" id="mlModelVersion">--</span>
        </div>
        <div class="ml-performance-grid">
          <div class="ml-stat">
            <div class="ml-stat-value ml-color" id="mlPredictedWinRate">--%</div>
            <div class="ml-stat-label">Predicted Win Rate</div>
          </div>
          <div class="ml-stat">
            <div class="ml-stat-value" id="mlActualWinRate">--%</div>
            <div class="ml-stat-label">Actual Win Rate</div>
          </div>
          <div class="ml-stat">
            <div class="ml-stat-value positive" id="mlAccuracy">--%</div>
            <div class="ml-stat-label">Model Accuracy</div>
          </div>
          <div class="ml-stat">
            <div class="ml-stat-value" id="mlSignalsCount">--</div>
            <div class="ml-stat-label">ML Signals</div>
          </div>
        </div>
        <div class="feature-importance" id="featureImportance"></div>
      </div>
    </div>

    <!-- TOP PICKS TRADE Section - Priority #1 -->
    <div class="top-picks-section" id="topPicksSection" data-collapsible="topPicks">
      <div class="top-picks-header" onclick="toggleCollapse('topPicksSection')">
        <div>
          <div class="top-picks-title">
            <span></span> TOP PICKS TRADE
            <span class="collapse-toggle">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </span>
          </div>
          <div class="top-picks-subtitle">Optimized for scalping & short-term trades with funding advantage</div>
        </div>
        <div style="font-size: 11px; color: #8b949e;">
          Updated every 5s | Funding = 8h cycle
        </div>
      </div>
      <div class="top-picks-grid">
        <!-- Long Picks Column -->
        <div class="picks-column long">
          <div class="picks-column-header">
            <span> BEST LONGS</span>
            <span id="topLongCount">0</span>
          </div>
          <div id="topLongPicks"></div>
        </div>
        <!-- Short Picks Column -->
        <div class="picks-column short">
          <div class="picks-column-header">
            <span> BEST SHORTS</span>
            <span id="topShortCount">0</span>
          </div>
          <div id="topShortPicks"></div>
        </div>
      </div>
    </div>

    <!-- Smart Signals Section -->
    <div class="section-header section-collapsible" onclick="toggleSection('smartSignalsSection')">
      <span class="section-icon"></span>
      <span class="section-title">SMART SIGNALS - AI-Powered Trade Detection</span>
      <span class="collapse-toggle">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="6 9 12 15 18 9"></polyline>
        </svg>
      </span>
    </div>

    <div class="smart-signals-section" id="smartSignalsSection">
      <!-- Top Long Signals -->
      <div class="panel smart-long">
        <div class="panel-header">
          <div class="panel-title">
            <span style="color: #3fb950;"></span> TOP LONG SIGNALS
          </div>
          <span class="panel-badge" id="longCount">0</span>
        </div>
        <div class="panel-content" id="smartLongPanel"></div>
      </div>

      <!-- Top Short Signals -->
      <div class="panel smart-short">
        <div class="panel-header">
          <div class="panel-title">
            <span style="color: #f85149;"></span> TOP SHORT SIGNALS
          </div>
          <span class="panel-badge" id="shortCount">0</span>
        </div>
        <div class="panel-content" id="smartShortPanel"></div>
      </div>

      <!-- Reversal Signals -->
      <div class="panel smart-reversal">
        <div class="panel-header">
          <div class="panel-title">
            <span style="color: #a371f7;"></span> REVERSAL SIGNALS
          </div>
          <span class="panel-badge" id="reversalCount">0</span>
        </div>
        <div class="panel-content" id="reversalPanel"></div>
      </div>
    </div>

    <!-- Early Entry & Breakout Section (part of Smart Signals) -->
    <div class="smart-signals-section" id="smartSignalsSection2" style="grid-template-columns: repeat(3, 1fr);">
      <!-- Early Entries -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">
            <span style="color: #58a6ff;"></span> EARLY ENTRIES
          </div>
          <span class="panel-badge" id="earlyCount">0</span>
        </div>
        <div class="panel-content" id="earlyEntriesPanel"></div>
      </div>

      <!-- Breakout Candidates -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">
            <span style="color: #d29922;"></span> BREAKOUT CANDIDATES
          </div>
          <span class="panel-badge" id="breakoutCount">0</span>
        </div>
        <div class="panel-content" id="breakoutPanel"></div>
      </div>

      <!-- Low Risk Setups -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">
            <span style="color: #3fb950;"></span> LOW RISK SETUPS
          </div>
          <span class="panel-badge" id="lowRiskCount">0</span>
        </div>
        <div class="panel-content" id="lowRiskPanel"></div>
      </div>
    </div>

    <!-- Market Data Section -->
    <div class="section-header section-collapsible" onclick="toggleSection('marketDataSection')">
      <span class="section-icon"></span>
      <span class="section-title">MARKET DATA</span>
      <span class="collapse-toggle">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="6 9 12 15 18 9"></polyline>
        </svg>
      </span>
    </div>

    <div class="panels-grid" id="marketDataSection">
      <!-- Top Movers -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title"> Top Movers (24H)</div>
          <span class="panel-badge" id="moversCount">0</span>
        </div>
        <div class="panel-content" id="topMoversPanel"></div>
      </div>

      <!-- Velocity Alerts -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title"> Velocity Alerts</div>
          <span class="panel-badge" id="velocityCount">0</span>
        </div>
        <div class="panel-content" id="velocityPanel"></div>
      </div>

      <!-- Volume Spikes -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title"> Volume Spikes</div>
          <span class="panel-badge" id="volumeCount">0</span>
        </div>
        <div class="panel-content" id="volumePanel"></div>
      </div>

      <!-- High Conviction -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title"> High Conviction</div>
          <span class="panel-badge" id="convictionCount">0</span>
        </div>
        <div class="panel-content" id="convictionPanel"></div>
      </div>
    </div>

    <!-- Advanced Indicators Section -->
    <div class="section-header section-collapsible" onclick="toggleSection('advancedIndicatorsSection')">
      <span class="section-icon"></span>
      <span class="section-title">ADVANCED INDICATORS</span>
      <span class="collapse-toggle">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="6 9 12 15 18 9"></polyline>
        </svg>
      </span>
    </div>

    <div class="panels-grid" id="advancedIndicatorsSection">
      <!-- Funding Rates -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title"> Extreme Funding</div>
          <span class="panel-badge" id="fundingCount">0</span>
        </div>
        <div class="panel-content" id="fundingPanel"></div>
      </div>

      <!-- Squeeze Setups -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title"> Squeeze Setups</div>
          <span class="panel-badge" id="squeezeCount">0</span>
        </div>
        <div class="panel-content" id="squeezePanel"></div>
      </div>

      <!-- Open Interest -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title"> OI Changes</div>
          <span class="panel-badge" id="oiCount">0</span>
        </div>
        <div class="panel-content" id="oiPanel"></div>
      </div>

      <!-- Multi-Timeframe -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title"> MTF Alignment</div>
          <span class="panel-badge" id="mtfCount">0</span>
        </div>
        <div class="panel-content" id="mtfPanel"></div>
      </div>

      <!-- RSI Extremes -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title"> RSI Extremes</div>
          <span class="panel-badge" id="rsiCount">0</span>
        </div>
        <div class="panel-content" id="rsiPanel"></div>
      </div>

      <!-- Divergences -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title"> Divergences</div>
          <span class="panel-badge" id="divCount">0</span>
        </div>
        <div class="panel-content" id="divergencePanel"></div>
      </div>
    </div>

    <!-- Advanced Detection Section -->
    <div class="section-header section-collapsible" onclick="toggleSection('advancedDetectionSection')">
      <span class="section-icon"></span>
      <span class="section-title">ADVANCED DETECTION</span>
      <span class="collapse-toggle">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="6 9 12 15 18 9"></polyline>
        </svg>
      </span>
    </div>

    <div class="panels-grid" id="advancedDetectionSection">
      <!-- Liquidation Alerts -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title"> Liquidation Alerts</div>
          <span class="panel-badge" id="liqCount">0</span>
        </div>
        <div class="panel-content" id="liquidationPanel"></div>
      </div>

      <!-- Whale Alerts -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title"> Whale Activity</div>
          <span class="panel-badge" id="whaleCount">0</span>
        </div>
        <div class="panel-content" id="whalePanel"></div>
      </div>

      <!-- BTC Correlation -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title"> BTC Correlation</div>
          <span class="panel-badge" id="corrCount">0</span>
        </div>
        <div class="panel-content" id="correlationPanel"></div>
      </div>

      <!-- Pattern Recognition -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title"> Pattern Detection</div>
          <span class="panel-badge" id="patternCount">0</span>
        </div>
        <div class="panel-content" id="patternPanel"></div>
      </div>
    </div>

    <!-- Entry Timing Section -->
    <div class="section-header section-collapsible" onclick="toggleSection('entryTimingSection')">
      <span class="section-icon"></span>
      <span class="section-title">SMART ENTRY TIMING</span>
      <span class="collapse-toggle">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="6 9 12 15 18 9"></polyline>
        </svg>
      </span>
    </div>

    <div class="panels-grid" id="entryTimingSection" style="grid-template-columns: repeat(2, 1fr);">
      <!-- Entry Signals Long -->
      <div class="panel smart-long">
        <div class="panel-header">
          <div class="panel-title">
            <span style="color: #3fb950;"></span> Long Entries with R:R
          </div>
          <span class="panel-badge" id="entryLongCount">0</span>
        </div>
        <div class="panel-content" id="entryLongPanel"></div>
      </div>

      <!-- Entry Signals Short -->
      <div class="panel smart-short">
        <div class="panel-header">
          <div class="panel-title">
            <span style="color: #f85149;"></span> Short Entries with R:R
          </div>
          <span class="panel-badge" id="entryShortCount">0</span>
        </div>
        <div class="panel-content" id="entryShortPanel"></div>
      </div>
    </div>
  </main>

  <script>
    // ====== COLLAPSE/EXPAND FUNCTIONALITY ======
    const COLLAPSE_STORAGE_KEY = 'signalsense_collapsed_sections';

    // Load collapsed state from localStorage
    function loadCollapsedState() {
      try {
        const saved = localStorage.getItem(COLLAPSE_STORAGE_KEY);
        return saved ? JSON.parse(saved) : { performanceSection: true }; // Performance collapsed by default
      } catch (e) {
        return { performanceSection: true };
      }
    }

    // Save collapsed state to localStorage
    function saveCollapsedState(state) {
      try {
        localStorage.setItem(COLLAPSE_STORAGE_KEY, JSON.stringify(state));
      } catch (e) {
        console.warn('Could not save collapse state');
      }
    }

    // Toggle collapse for sections (performance, top picks)
    function toggleCollapse(elementId) {
      const element = document.getElementById(elementId);
      if (!element) return;

      element.classList.toggle('collapsed');

      // Update toggle icon rotation
      const toggle = element.querySelector('.collapse-toggle');
      if (toggle) {
        toggle.style.transform = element.classList.contains('collapsed') ? 'rotate(-90deg)' : 'rotate(0deg)';
      }

      // Save state
      const state = loadCollapsedState();
      state[elementId] = element.classList.contains('collapsed');
      saveCollapsedState(state);
    }

    // Toggle collapse for section grids (smart signals, market data, etc.)
    function toggleSection(sectionId) {
      const section = document.getElementById(sectionId);
      if (!section) return;

      section.classList.toggle('collapsed');

      // Also toggle the second smart signals section if toggling the first
      if (sectionId === 'smartSignalsSection') {
        const section2 = document.getElementById('smartSignalsSection2');
        if (section2) {
          section2.classList.toggle('collapsed');
        }
      }

      // Update the header's toggle icon
      const headers = document.querySelectorAll('.section-header.section-collapsible');
      headers.forEach(header => {
        const onclick = header.getAttribute('onclick');
        if (onclick && onclick.includes(sectionId)) {
          const toggle = header.querySelector('.collapse-toggle');
          if (toggle) {
            toggle.style.transform = section.classList.contains('collapsed') ? 'rotate(-90deg)' : 'rotate(0deg)';
          }
        }
      });

      // Save state
      const state = loadCollapsedState();
      state[sectionId] = section.classList.contains('collapsed');
      if (sectionId === 'smartSignalsSection') {
        state['smartSignalsSection2'] = section.classList.contains('collapsed');
      }
      saveCollapsedState(state);
    }

    // Toggle collapse for individual panels
    function togglePanel(panelElement) {
      panelElement.classList.toggle('collapsed');
    }

    // Initialize collapsed states on page load
    function initializeCollapseStates() {
      const state = loadCollapsedState();

      Object.entries(state).forEach(([id, isCollapsed]) => {
        const element = document.getElementById(id);
        if (element && isCollapsed) {
          element.classList.add('collapsed');

          // Update toggle icon
          const toggle = element.querySelector('.collapse-toggle');
          if (toggle) {
            toggle.style.transform = 'rotate(-90deg)';
          }

          // For section headers, find and update their toggles
          const headers = document.querySelectorAll('.section-header.section-collapsible');
          headers.forEach(header => {
            const onclick = header.getAttribute('onclick');
            if (onclick && onclick.includes(id)) {
              const headerToggle = header.querySelector('.collapse-toggle');
              if (headerToggle) {
                headerToggle.style.transform = 'rotate(-90deg)';
              }
            }
          });
        }
      });

      // Add collapse toggle icons and click handlers to all panels
      addPanelCollapseHandlers();
    }

    // Add collapse functionality to all individual panels
    function addPanelCollapseHandlers() {
      const panels = document.querySelectorAll('.panel');
      const state = loadCollapsedState();

      panels.forEach((panel, index) => {
        const header = panel.querySelector('.panel-header');
        if (!header) return;

        // Create unique ID for this panel if it doesn't have one
        const panelId = panel.id || `panel-${index}`;
        if (!panel.id) panel.id = panelId;

        // Add collapse toggle icon if not already present
        if (!header.querySelector('.collapse-toggle')) {
          const toggle = document.createElement('span');
          toggle.className = 'collapse-toggle';
          toggle.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"></polyline></svg>';
          header.appendChild(toggle);
        }

        // Add click handler
        header.addEventListener('click', function(e) {
          e.stopPropagation();
          panel.classList.toggle('collapsed');

          const toggle = header.querySelector('.collapse-toggle');
          if (toggle) {
            toggle.style.transform = panel.classList.contains('collapsed') ? 'rotate(-90deg)' : 'rotate(0deg)';
          }

          // Save state
          const currentState = loadCollapsedState();
          currentState[panelId] = panel.classList.contains('collapsed');
          saveCollapsedState(currentState);
        });

        // Restore collapsed state
        if (state[panelId]) {
          panel.classList.add('collapsed');
          const toggle = header.querySelector('.collapse-toggle');
          if (toggle) {
            toggle.style.transform = 'rotate(-90deg)';
          }
        }
      });
    }

    // Run initialization after DOM is ready
    document.addEventListener('DOMContentLoaded', initializeCollapseStates);

    // ====== MAIN APPLICATION ======
    const socket = io();

    // DOM Elements
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const symbolCount = document.getElementById('symbolCount');
    const lastUpdate = document.getElementById('lastUpdate');

    // ML Status Elements
    const mlStatusDot = document.getElementById('mlStatusDot');
    const mlStatusText = document.getElementById('mlStatusText');
    const mlVersion = document.getElementById('mlVersion');
    const mlModelVersion = document.getElementById('mlModelVersion');
    const mlPredictedWinRate = document.getElementById('mlPredictedWinRate');
    const mlActualWinRate = document.getElementById('mlActualWinRate');
    const mlAccuracy = document.getElementById('mlAccuracy');
    const mlSignalsCount = document.getElementById('mlSignalsCount');
    const featureImportance = document.getElementById('featureImportance');

    // Filter elements
    const minVolumeFilter = document.getElementById('minVolumeFilter');
    const presetButtons = document.querySelectorAll('.filter-btn.preset');

    // Panel elements
    const panels = {
      smartLong: document.getElementById('smartLongPanel'),
      smartShort: document.getElementById('smartShortPanel'),
      reversal: document.getElementById('reversalPanel'),
      earlyEntries: document.getElementById('earlyEntriesPanel'),
      breakout: document.getElementById('breakoutPanel'),
      lowRisk: document.getElementById('lowRiskPanel'),
      topMovers: document.getElementById('topMoversPanel'),
      velocity: document.getElementById('velocityPanel'),
      volume: document.getElementById('volumePanel'),
      conviction: document.getElementById('convictionPanel'),
      funding: document.getElementById('fundingPanel'),
      squeeze: document.getElementById('squeezePanel'),
      oi: document.getElementById('oiPanel'),
      mtf: document.getElementById('mtfPanel'),
      rsi: document.getElementById('rsiPanel'),
      divergence: document.getElementById('divergencePanel'),
      // New advanced panels
      liquidation: document.getElementById('liquidationPanel'),
      whale: document.getElementById('whalePanel'),
      correlation: document.getElementById('correlationPanel'),
      pattern: document.getElementById('patternPanel'),
      entryLong: document.getElementById('entryLongPanel'),
      entryShort: document.getElementById('entryShortPanel'),
    };

    // Badge elements
    const badges = {
      long: document.getElementById('longCount'),
      short: document.getElementById('shortCount'),
      reversal: document.getElementById('reversalCount'),
      early: document.getElementById('earlyCount'),
      breakout: document.getElementById('breakoutCount'),
      lowRisk: document.getElementById('lowRiskCount'),
      movers: document.getElementById('moversCount'),
      velocity: document.getElementById('velocityCount'),
      volume: document.getElementById('volumeCount'),
      conviction: document.getElementById('convictionCount'),
      funding: document.getElementById('fundingCount'),
      squeeze: document.getElementById('squeezeCount'),
      oi: document.getElementById('oiCount'),
      mtf: document.getElementById('mtfCount'),
      rsi: document.getElementById('rsiCount'),
      div: document.getElementById('divCount'),
      // New badges
      liq: document.getElementById('liqCount'),
      whale: document.getElementById('whaleCount'),
      corr: document.getElementById('corrCount'),
      pattern: document.getElementById('patternCount'),
      entryLong: document.getElementById('entryLongCount'),
      entryShort: document.getElementById('entryShortCount'),
    };

    // Sentiment and stats elements
    const sentimentValue = document.getElementById('sentimentValue');
    const sentimentNeedle = document.getElementById('sentimentNeedle');
    const sentimentScore = document.getElementById('sentimentScore');
    const winRateEl = document.getElementById('winRate');
    const totalSignalsEl = document.getElementById('totalSignals');
    const bullishCountEl = document.getElementById('bullishCount');
    const bearishCountEl = document.getElementById('bearishCount');
    const notificationContainer = document.getElementById('notificationContainer');

    // Performance tracking elements
    const perfWinRate = document.getElementById('perfWinRate');
    const perfTotalSignals = document.getElementById('perfTotalSignals');
    const perfWins = document.getElementById('perfWins');
    const perfLosses = document.getElementById('perfLosses');
    const perfAvgWin = document.getElementById('perfAvgWin');
    const perfAvgLoss = document.getElementById('perfAvgLoss');
    const typePerformance = document.getElementById('typePerformance');
    const signalsTable = document.getElementById('signalsTable');
    const recentSignalsCount = document.getElementById('recentSignalsCount');
    const performanceLastUpdate = document.getElementById('performanceLastUpdate');

    // Price history cache for sparklines
    const priceHistoryCache = new Map();

    // Top Picks elements
    const topLongPicks = document.getElementById('topLongPicks');
    const topShortPicks = document.getElementById('topShortPicks');
    const topLongCount = document.getElementById('topLongCount');
    const topShortCount = document.getElementById('topShortCount');

    // Helper functions
    function formatNumber(num) {
      if (num === undefined || num === null || isNaN(num)) return '0.00';
      if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
      if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
      if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
      return num.toFixed(2);
    }

    function formatPercent(num) {
      if (num === undefined || num === null || isNaN(num)) return '0.00%';
      const sign = num >= 0 ? '+' : '';
      return sign + num.toFixed(2) + '%';
    }

    function openBinance(symbol) {
      window.open('https://www.binance.com/en/futures/' + symbol, '_blank');
    }

    function getConfidenceClass(confidence) {
      if (confidence >= 70) return 'high';
      if (confidence >= 50) return 'medium';
      return 'low';
    }

    // ====== SPARKLINE CHART FUNCTIONS ======
    function createSparkline(prices, width, height) {
      if (!prices || prices.length < 2) {
        return null;
      }

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('class', 'sparkline');
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'none');

      const values = prices.map(p => p.price);
      const min = Math.min(...values);
      const max = Math.max(...values);
      const range = max - min || 1;

      // Normalize values to fit in the SVG
      const points = values.map((v, i) => {
        const x = (i / (values.length - 1)) * width;
        const y = height - ((v - min) / range) * (height - 4) - 2;
        return `${x.toFixed(1)},${y.toFixed(1)}`;
      });

      // Determine trend
      const firstPrice = values[0];
      const lastPrice = values[values.length - 1];
      const trendClass = lastPrice > firstPrice ? 'up' : (lastPrice < firstPrice ? 'down' : 'neutral');

      // Create path
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('class', 'sparkline-path ' + trendClass);
      path.setAttribute('d', 'M' + points.join(' L'));

      svg.appendChild(path);

      // Add end dot
      const lastPoint = points[points.length - 1].split(',');
      const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      dot.setAttribute('class', 'sparkline-dot ' + trendClass);
      dot.setAttribute('cx', lastPoint[0]);
      dot.setAttribute('cy', lastPoint[1]);
      dot.setAttribute('r', '2');
      svg.appendChild(dot);

      return svg;
    }

    // Fetch price history for a symbol
    async function fetchPriceHistory(symbol) {
      // Check cache first (valid for 5 seconds)
      const cached = priceHistoryCache.get(symbol);
      if (cached && Date.now() - cached.timestamp < 5000) {
        return cached.data;
      }

      try {
        const response = await fetch('/api/price-history/' + symbol);
        const data = await response.json();
        priceHistoryCache.set(symbol, { data: data.history, timestamp: Date.now() });
        return data.history;
      } catch (e) {
        console.error('Failed to fetch price history for', symbol);
        return null;
      }
    }

    // ====== PERFORMANCE TRACKING FUNCTIONS ======
    function updatePerformancePanel(stats, recentSignals) {
      if (!stats) return;

      // Update main stats
      if (stats.winRate !== undefined) {
        perfWinRate.textContent = stats.winRate.toFixed(1) + '%';
        perfWinRate.className = 'performance-stat-value ' + (stats.winRate >= 50 ? 'positive' : 'negative');
      }

      if (stats.totalSignals !== undefined) {
        perfTotalSignals.textContent = stats.totalSignals;
      }

      if (stats.wins !== undefined) {
        perfWins.textContent = stats.wins;
      }

      if (stats.losses !== undefined) {
        perfLosses.textContent = stats.losses;
      }

      // Update pending count
      const perfPending = document.getElementById('perfPending');
      if (stats.pending !== undefined && perfPending) {
        perfPending.textContent = stats.pending;
      }

      if (stats.avgWinPercent !== undefined) {
        perfAvgWin.textContent = '+' + stats.avgWinPercent.toFixed(2) + '%';
        perfAvgWin.className = 'performance-stat-value positive';
      }

      if (stats.avgLossPercent !== undefined) {
        perfAvgLoss.textContent = stats.avgLossPercent.toFixed(2) + '%';
        perfAvgLoss.className = 'performance-stat-value negative';
      }

      // Update timestamp
      performanceLastUpdate.textContent = 'Updated: ' + new Date().toLocaleTimeString();

      // Update by-type performance
      if (stats.byType && typePerformance) {
        typePerformance.innerHTML = '';
        Object.entries(stats.byType).forEach(([type, typeStats]) => {
          // Show if there are completed OR pending signals
          if (typeStats.totalSignals > 0 || typeStats.pending > 0) {
            const typeStat = document.createElement('div');
            typeStat.className = 'type-stat';

            const label = document.createElement('span');
            label.className = 'type-stat-label';
            label.textContent = type + ':';

            const value = document.createElement('span');
            if (typeStats.totalSignals > 0) {
              value.className = 'type-stat-value ' + (typeStats.winRate >= 50 ? 'positive' : 'negative');
              value.textContent = typeStats.winRate.toFixed(0) + '% (' + typeStats.totalSignals + ')';
            } else {
              // Only pending signals
              value.className = 'type-stat-value pending';
              value.textContent = typeStats.pending + ' pending';
            }

            typeStat.appendChild(label);
            typeStat.appendChild(value);
            typePerformance.appendChild(typeStat);
          }
        });
      }

      // Update recent signals table
      if (recentSignals && signalsTable) {
        signalsTable.innerHTML = '';
        recentSignalsCount.textContent = recentSignals.length + ' signals';

        if (recentSignals.length === 0) {
          signalsTable.innerHTML = '<div class="empty-state">No signals recorded yet</div>';
          return;
        }

        recentSignals.forEach(signal => {
          const row = document.createElement('div');
          row.className = 'signal-row';
          row.onclick = () => openBinance(signal.symbol);

          // Symbol
          const symbolCell = document.createElement('div');
          symbolCell.className = 'signal-symbol';
          symbolCell.textContent = signal.symbol;

          // Sparkline
          const sparklineCell = document.createElement('div');
          sparklineCell.className = 'signal-sparkline';
          fetchPriceHistory(signal.symbol).then(history => {
            if (history && history.length > 0) {
              const sparkline = createSparkline(history, 70, 24);
              if (sparkline) {
                sparklineCell.appendChild(sparkline);
              }
            }
          });

          // Direction
          const dirCell = document.createElement('div');
          dirCell.className = 'signal-direction ' + signal.direction.toLowerCase();
          dirCell.textContent = signal.direction;

          // Entry price
          const entryCell = document.createElement('div');
          entryCell.className = 'signal-entry';
          entryCell.textContent = '$' + (signal.entryPrice ? signal.entryPrice.toFixed(4) : '--');

          // P&L
          const pnlCell = document.createElement('div');
          const pnl = signal.pnlPercent || 0;
          pnlCell.className = 'signal-pnl ' + (pnl >= 0 ? 'positive' : 'negative');
          pnlCell.textContent = (pnl >= 0 ? '+' : '') + pnl.toFixed(2) + '%';

          // Outcome
          const outcomeCell = document.createElement('div');
          const outcome = signal.outcome || 'PENDING';
          outcomeCell.className = 'signal-outcome ' + outcome.toLowerCase();
          outcomeCell.textContent = outcome;

          // Time
          const timeCell = document.createElement('div');
          timeCell.className = 'signal-time';
          timeCell.textContent = new Date(signal.timestamp).toLocaleTimeString();

          row.appendChild(symbolCell);
          row.appendChild(sparklineCell);
          row.appendChild(dirCell);
          row.appendChild(entryCell);
          row.appendChild(pnlCell);
          row.appendChild(outcomeCell);
          row.appendChild(timeCell);

          signalsTable.appendChild(row);
        });
      }
    }

    // ====== RENDER ITEM WITH SPARKLINE ======
    function renderItemWithSparkline(data, container, options = {}) {
      const div = document.createElement('div');
      div.className = 'item-with-sparkline';
      div.onclick = () => openBinance(data.symbol);

      const value = options.valueField ? data[options.valueField] : data.change24h || 0;
      const valueText = options.valueFormat ? options.valueFormat(data) : formatPercent(value);
      const metaText = options.metaFormat ? options.metaFormat(data) : '';
      const subText = options.subFormat ? options.subFormat(data) : '';

      // Determine direction for coloring
      const directionValue = options.directionField ? data[options.directionField] : value;
      const isPositive = directionValue > 0;
      const isNegative = directionValue < 0;
      const directionClass = isPositive ? 'positive' : (isNegative ? 'negative' : '');

      // Main content wrapper
      const mainDiv = document.createElement('div');
      mainDiv.className = 'item-main';

      const leftDiv = document.createElement('div');
      leftDiv.className = 'item-left';

      const symbolSpan = document.createElement('span');
      symbolSpan.className = 'item-symbol' + (options.colorSymbol && directionClass ? ' ' + directionClass : '');
      symbolSpan.textContent = data.symbol;
      leftDiv.appendChild(symbolSpan);

      if (metaText) {
        const metaSpan = document.createElement('span');
        metaSpan.className = 'item-meta';
        metaSpan.textContent = metaText;
        leftDiv.appendChild(metaSpan);
      }

      const rightDiv = document.createElement('div');
      rightDiv.className = 'item-right';

      const valueSpan = document.createElement('span');
      valueSpan.className = 'item-value' + (directionClass ? ' ' + directionClass : '');
      valueSpan.textContent = valueText;
      rightDiv.appendChild(valueSpan);

      if (subText) {
        const subSpan = document.createElement('span');
        subSpan.className = 'item-sub';
        subSpan.textContent = subText;
        rightDiv.appendChild(subSpan);
      }

      mainDiv.appendChild(leftDiv);
      mainDiv.appendChild(rightDiv);
      div.appendChild(mainDiv);

      // Add sparkline container (async load)
      if (options.showSparkline !== false) {
        const sparkContainer = document.createElement('div');
        sparkContainer.className = 'sparkline-container';
        sparkContainer.id = 'spark-' + data.symbol;
        div.appendChild(sparkContainer);

        // Fetch and render sparkline asynchronously
        fetchPriceHistory(data.symbol).then(history => {
          if (history && history.length >= 2) {
            const sparkline = createSparkline(history, 60, 24);
            if (sparkline && sparkContainer.parentNode) {
              sparkContainer.appendChild(sparkline);
            }
          }
        });
      }

      container.appendChild(div);
    }

    // Helper function to create ML confidence item
    function createMLConfidenceItem(label, value, className) {
      const item = document.createElement('div');
      item.className = 'ml-confidence-item';
      const labelSpan = document.createElement('span');
      labelSpan.className = 'ml-confidence-label';
      labelSpan.textContent = label + ':';
      const valueSpan = document.createElement('span');
      valueSpan.className = 'ml-confidence-value ' + className;
      valueSpan.textContent = value;
      item.appendChild(labelSpan);
      item.appendChild(valueSpan);
      return item;
    }

    // Render functions
    function renderSmartSignal(signal, container) {
      const div = document.createElement('div');
      let className = 'smart-item ' + signal.direction.toLowerCase();

      // Add ML enhanced class if signal has ML prediction
      if (signal.mlEnhanced) {
        className += ' ml-enhanced';
      }
      div.className = className;
      div.onclick = () => openBinance(signal.symbol);

      const confClass = getConfidenceClass(signal.combinedConfidence || signal.confidence);
      const riskClass = 'risk-' + signal.riskLevel.toLowerCase();

      const header = document.createElement('div');
      header.className = 'smart-item-header';

      const symbolSpan = document.createElement('span');
      symbolSpan.className = 'smart-item-symbol';
      symbolSpan.textContent = signal.symbol;

      const dirSpan = document.createElement('span');
      dirSpan.className = 'smart-item-direction ' + signal.direction.toLowerCase();
      dirSpan.textContent = signal.direction;

      header.appendChild(symbolSpan);
      header.appendChild(dirSpan);

      // Add quality tier badge if ML enhanced
      if (signal.qualityTier) {
        const tierBadge = document.createElement('span');
        tierBadge.className = 'quality-tier-badge tier-' + signal.qualityTier.toLowerCase();
        tierBadge.textContent = signal.qualityTier;
        header.appendChild(tierBadge);
      }

      const confDiv = document.createElement('div');
      confDiv.className = 'smart-item-confidence';

      const confBar = document.createElement('div');
      confBar.className = 'confidence-bar';
      const confFill = document.createElement('div');
      confFill.className = 'confidence-fill ' + confClass;
      // Use combined confidence if available
      const displayConf = signal.combinedConfidence || signal.confidence;
      confFill.style.width = displayConf + '%';
      confBar.appendChild(confFill);

      const confText = document.createElement('span');
      confText.className = 'confidence-text';
      confText.textContent = displayConf.toFixed(0) + '%';

      confDiv.appendChild(confBar);
      confDiv.appendChild(confText);

      const metaDiv = document.createElement('div');
      metaDiv.className = 'smart-item-meta';

      const entryTag = document.createElement('span');
      entryTag.className = 'meta-tag entry-type';
      entryTag.textContent = signal.entryType;

      const riskTag = document.createElement('span');
      riskTag.className = 'meta-tag ' + riskClass;
      riskTag.textContent = signal.riskLevel + ' RISK';

      const priceTag = document.createElement('span');
      priceTag.className = 'meta-tag';
      priceTag.textContent = '$' + formatNumber(signal.price);

      metaDiv.appendChild(entryTag);
      metaDiv.appendChild(riskTag);
      metaDiv.appendChild(priceTag);

      const reasonsDiv = document.createElement('div');
      reasonsDiv.className = 'smart-item-reasons';
      reasonsDiv.textContent = signal.reasoning ? signal.reasoning.slice(0, 2).join('  ') : '';

      div.appendChild(header);
      div.appendChild(confDiv);
      div.appendChild(metaDiv);
      div.appendChild(reasonsDiv);

      // Add ML confidence row if ML enhanced
      if (signal.mlEnhanced && signal.mlPrediction) {
        const mlRow = document.createElement('div');
        mlRow.className = 'ml-confidence-row';

        // Rule-based confidence
        mlRow.appendChild(createMLConfidenceItem('Rule', signal.confidence.toFixed(0) + '%', 'rule'));

        // ML confidence
        const mlConf = (signal.mlPrediction.win_probability * 100).toFixed(0);
        mlRow.appendChild(createMLConfidenceItem('ML', mlConf + '%', 'ml'));

        // Win probability
        const winProb = signal.mlPrediction.win_probability * 100;
        let winProbClass = 'low';
        if (winProb >= 70) winProbClass = 'high';
        else if (winProb >= 55) winProbClass = 'medium';
        const winItem = document.createElement('div');
        winItem.className = 'win-prob';
        const winLabel = document.createElement('span');
        winLabel.className = 'ml-confidence-label';
        winLabel.textContent = 'Win:';
        const winValue = document.createElement('span');
        winValue.className = 'win-prob-value ' + winProbClass;
        winValue.textContent = winProb.toFixed(0) + '%';
        winItem.appendChild(winLabel);
        winItem.appendChild(winValue);
        mlRow.appendChild(winItem);

        div.appendChild(mlRow);
      }

      container.appendChild(div);
    }

    function renderReversalSignal(signal, container) {
      const div = document.createElement('div');
      const isBullish = signal.type === 'BULLISH_REVERSAL';
      div.className = 'reversal-item' + (isBullish ? '' : ' bearish');
      div.onclick = () => openBinance(signal.symbol);

      const header = document.createElement('div');
      header.className = 'smart-item-header';

      const symbolSpan = document.createElement('span');
      symbolSpan.className = 'smart-item-symbol';
      symbolSpan.textContent = signal.symbol;

      const typeSpan = document.createElement('span');
      typeSpan.className = 'smart-item-direction';
      typeSpan.style.background = isBullish ? 'rgba(163, 113, 247, 0.2)' : 'rgba(240, 136, 62, 0.2)';
      typeSpan.style.color = isBullish ? '#a371f7' : '#f0883e';
      typeSpan.textContent = (isBullish ? ' BULLISH' : ' BEARISH') + ' REVERSAL';

      header.appendChild(symbolSpan);
      header.appendChild(typeSpan);

      const confDiv = document.createElement('div');
      confDiv.className = 'smart-item-confidence';

      const confBar = document.createElement('div');
      confBar.className = 'confidence-bar';
      const confFill = document.createElement('div');
      confFill.className = 'confidence-fill ' + getConfidenceClass(signal.confidence);
      confFill.style.width = signal.confidence + '%';
      confBar.appendChild(confFill);

      const confText = document.createElement('span');
      confText.className = 'confidence-text';
      confText.textContent = signal.confidence.toFixed(0) + '%';

      confDiv.appendChild(confBar);
      confDiv.appendChild(confText);

      const triggersDiv = document.createElement('div');
      triggersDiv.className = 'reversal-triggers';
      if (signal.triggers) {
        signal.triggers.forEach(t => {
          const triggerDiv = document.createElement('div');
          triggerDiv.className = 'reversal-trigger';
          triggerDiv.textContent = ' ' + t;
          triggersDiv.appendChild(triggerDiv);
        });
      }

      const levelsDiv = document.createElement('div');
      levelsDiv.className = 'reversal-levels';

      const entryLevel = document.createElement('div');
      entryLevel.className = 'reversal-level';
      const entryLabel = document.createElement('span');
      entryLabel.className = 'reversal-level-label';
      entryLabel.textContent = 'Entry';
      const entryValue = document.createElement('span');
      entryValue.className = 'reversal-level-value';
      entryValue.textContent = '$' + signal.price.toFixed(4);
      entryLevel.appendChild(entryLabel);
      entryLevel.appendChild(entryValue);

      const targetLevel = document.createElement('div');
      targetLevel.className = 'reversal-level';
      const targetLabel = document.createElement('span');
      targetLabel.className = 'reversal-level-label';
      targetLabel.textContent = 'Target';
      const targetValue = document.createElement('span');
      targetValue.className = 'reversal-level-value target';
      targetValue.textContent = '$' + signal.potentialTarget.toFixed(4);
      targetLevel.appendChild(targetLabel);
      targetLevel.appendChild(targetValue);

      const stopLevel = document.createElement('div');
      stopLevel.className = 'reversal-level';
      const stopLabel = document.createElement('span');
      stopLabel.className = 'reversal-level-label';
      stopLabel.textContent = 'Stop';
      const stopValue = document.createElement('span');
      stopValue.className = 'reversal-level-value stop';
      stopValue.textContent = '$' + signal.stopLoss.toFixed(4);
      stopLevel.appendChild(stopLabel);
      stopLevel.appendChild(stopValue);

      levelsDiv.appendChild(entryLevel);
      levelsDiv.appendChild(targetLevel);
      levelsDiv.appendChild(stopLevel);

      div.appendChild(header);
      div.appendChild(confDiv);
      div.appendChild(triggersDiv);
      div.appendChild(levelsDiv);

      container.appendChild(div);
    }

    function renderItem(data, container, options = {}) {
      const div = document.createElement('div');
      div.className = 'item';
      div.onclick = () => openBinance(data.symbol);

      const value = options.valueField ? data[options.valueField] : data.change24h || 0;
      const valueText = options.valueFormat ? options.valueFormat(data) : formatPercent(value);
      const metaText = options.metaFormat ? options.metaFormat(data) : '';
      const subText = options.subFormat ? options.subFormat(data) : '';

      // Determine direction for coloring
      const directionValue = options.directionField ? data[options.directionField] : value;
      const isPositive = directionValue > 0;
      const isNegative = directionValue < 0;
      const directionClass = isPositive ? 'positive' : (isNegative ? 'negative' : '');

      const leftDiv = document.createElement('div');
      leftDiv.className = 'item-left';

      const symbolSpan = document.createElement('span');
      symbolSpan.className = 'item-symbol' + (options.colorSymbol && directionClass ? ' ' + directionClass : '');
      symbolSpan.textContent = data.symbol;
      leftDiv.appendChild(symbolSpan);

      if (metaText) {
        const metaSpan = document.createElement('span');
        metaSpan.className = 'item-meta';
        metaSpan.textContent = metaText;
        leftDiv.appendChild(metaSpan);
      }

      const rightDiv = document.createElement('div');
      rightDiv.className = 'item-right';

      const valueSpan = document.createElement('span');
      valueSpan.className = 'item-value' + (directionClass ? ' ' + directionClass : '');
      valueSpan.textContent = valueText;
      rightDiv.appendChild(valueSpan);

      if (subText) {
        const subSpan = document.createElement('span');
        subSpan.className = 'item-sub';
        subSpan.textContent = subText;
        rightDiv.appendChild(subSpan);
      }

      div.appendChild(leftDiv);
      div.appendChild(rightDiv);

      container.appendChild(div);
    }

    function clearPanel(panel) {
      while (panel.firstChild) {
        panel.removeChild(panel.firstChild);
      }
    }

    function renderEmptyState(panel, message) {
      message = message || 'No data available';
      const div = document.createElement('div');
      div.className = 'empty-state';
      div.textContent = message;
      panel.appendChild(div);
    }

    // Render entry signal with R:R
    function renderEntrySignal(signal, container) {
      const div = document.createElement('div');
      div.className = 'entry-item';
      div.onclick = function() { openBinance(signal.symbol); };

      const isLong = signal.direction === 'LONG';
      const symbolClass = isLong ? 'positive' : 'negative';

      const header = document.createElement('div');
      header.className = 'entry-header';

      const symbolSpan = document.createElement('span');
      symbolSpan.className = 'entry-symbol ' + symbolClass;
      symbolSpan.textContent = signal.symbol;

      const typeSpan = document.createElement('span');
      typeSpan.className = 'entry-type';
      typeSpan.textContent = signal.entryType;

      header.appendChild(symbolSpan);
      header.appendChild(typeSpan);

      const levels = document.createElement('div');
      levels.className = 'entry-levels';

      var entryLevel = document.createElement('div');
      entryLevel.className = 'entry-level';
      entryLevel.innerHTML = '<span class="entry-level-label">Entry:</span><span class="entry-level-value entry">$' + signal.entryPrice.toFixed(4) + '</span>';

      var slLevel = document.createElement('div');
      slLevel.className = 'entry-level';
      slLevel.innerHTML = '<span class="entry-level-label">SL:</span><span class="entry-level-value sl">$' + signal.stopLoss.toFixed(4) + '</span>';

      var tpLevel = document.createElement('div');
      tpLevel.className = 'entry-level';
      tpLevel.innerHTML = '<span class="entry-level-label">TP1:</span><span class="entry-level-value tp">$' + signal.takeProfit1.toFixed(4) + '</span>';

      levels.appendChild(entryLevel);
      levels.appendChild(slLevel);
      levels.appendChild(tpLevel);

      const rrDiv = document.createElement('div');
      rrDiv.className = 'entry-rr';
      rrDiv.textContent = 'R:R ' + signal.riskRewardRatio + ' | Conf: ' + signal.confidence.toFixed(0) + '%';

      div.appendChild(header);
      div.appendChild(levels);
      div.appendChild(rrDiv);

      container.appendChild(div);
    }

    // Render notification toast
    function renderNotification(notification) {
      const toast = document.createElement('div');
      toast.className = 'notification-toast ' + notification.priority.toLowerCase();
      toast.onclick = function() {
        openBinance(notification.symbol);
        toast.remove();
      };

      const header = document.createElement('div');
      header.className = 'notification-header';

      const title = document.createElement('span');
      title.className = 'notification-title';
      title.textContent = notification.title;

      header.appendChild(title);

      if (notification.direction) {
        const dir = document.createElement('span');
        dir.className = 'notification-direction ' + notification.direction.toLowerCase();
        dir.textContent = notification.direction;
        header.appendChild(dir);
      }

      const message = document.createElement('div');
      message.className = 'notification-message';
      message.textContent = notification.message;

      toast.appendChild(header);
      toast.appendChild(message);

      notificationContainer.appendChild(toast);

      // Auto-remove after 10 seconds
      setTimeout(function() {
        if (toast.parentNode) {
          toast.remove();
        }
      }, 10000);
    }

    // Update sentiment display
    function updateSentiment(sentiment) {
      if (!sentiment) return;

      sentimentScore.textContent = sentiment.overallScore;
      sentimentNeedle.style.left = sentiment.overallScore + '%';

      var sentimentClass = 'neutral';
      var sentimentText = sentiment.sentiment.replace(/_/g, ' ');
      if (sentiment.sentiment === 'EXTREME_FEAR') sentimentClass = 'extreme-fear';
      else if (sentiment.sentiment === 'FEAR') sentimentClass = 'fear';
      else if (sentiment.sentiment === 'GREED') sentimentClass = 'greed';
      else if (sentiment.sentiment === 'EXTREME_GREED') sentimentClass = 'extreme-greed';

      sentimentValue.className = 'sentiment-value ' + sentimentClass;
      sentimentValue.textContent = sentimentText;

      // Update bullish/bearish counts
      if (sentiment.indicators) {
        bullishCountEl.textContent = sentiment.indicators.bullishCoins || 0;
        bearishCountEl.textContent = sentiment.indicators.bearishCoins || 0;
      }
    }

    // Update win rate stats
    function updateWinRateStats(stats) {
      if (!stats) return;

      if (stats.winRate !== undefined) {
        winRateEl.textContent = stats.winRate.toFixed(1) + '%';
        winRateEl.className = 'stat-value ' + (stats.winRate >= 50 ? 'positive' : 'negative');
      }

      if (stats.totalSignals !== undefined) {
        totalSignalsEl.textContent = stats.totalSignals;
      }
    }

    // Update ML Status display
    function updateMLStatus(mlStatus, mlFeatureCounts) {
      if (!mlStatus) return;

      // Update ML status badge in header
      if (mlStatus.serviceAvailable && mlStatus.enabled) {
        mlStatusDot.className = 'ml-status-dot active';
        mlStatusText.textContent = 'Active';
        if (mlStatus.modelVersion) {
          mlVersion.textContent = '(v' + mlStatus.modelVersion + ')';
        }
      } else if (mlStatus.enabled) {
        mlStatusDot.className = 'ml-status-dot inactive';
        mlStatusText.textContent = 'Offline';
        mlVersion.textContent = '';
      } else {
        mlStatusDot.className = 'ml-status-dot inactive';
        mlStatusText.textContent = 'Disabled';
        mlVersion.textContent = '';
      }

      // Update ML performance panel
      if (mlStatus.modelVersion && mlModelVersion) {
        mlModelVersion.textContent = 'v' + mlStatus.modelVersion;
      }

      // Update signals count from feature counts
      if (mlFeatureCounts && mlSignalsCount) {
        const total = (mlFeatureCounts.total || 0);
        const withOutcome = (mlFeatureCounts.withOutcome || 0);
        mlSignalsCount.textContent = withOutcome + '/' + total;
      }
    }

    // Update ML accuracy stats (called separately via API or socket)
    function updateMLAccuracyStats(stats) {
      if (!stats) return;

      if (stats.predictedWinRate !== undefined && mlPredictedWinRate) {
        mlPredictedWinRate.textContent = stats.predictedWinRate.toFixed(1) + '%';
      }

      if (stats.actualWinRate !== undefined && mlActualWinRate) {
        mlActualWinRate.textContent = stats.actualWinRate.toFixed(1) + '%';
        mlActualWinRate.className = 'ml-stat-value ' + (stats.actualWinRate >= 50 ? 'positive' : 'negative');
      }

      if (stats.accuracy !== undefined && mlAccuracy) {
        mlAccuracy.textContent = stats.accuracy.toFixed(1) + '%';
        mlAccuracy.className = 'ml-stat-value ' + (stats.accuracy >= 70 ? 'positive' : stats.accuracy >= 50 ? '' : 'negative');
      }
    }

    // Market Hours Configuration
    const marketConfig = {
      NYSE: {
        name: 'NYSE/NASDAQ',
        timezone: 'America/New_York',
        openHour: 9, openMinute: 30,
        closeHour: 16, closeMinute: 0,
        weekdays: [1, 2, 3, 4, 5], // Mon-Fri
        itemId: 'marketNYSE',
        dotId: 'nyseStatusDot',
        textId: 'nyseStatusText',
        timeId: 'nyseTime'
      },
      LSE: {
        name: 'London',
        timezone: 'Europe/London',
        openHour: 8, openMinute: 0,
        closeHour: 16, closeMinute: 30,
        weekdays: [1, 2, 3, 4, 5],
        itemId: 'marketLSE',
        dotId: 'lseStatusDot',
        textId: 'lseStatusText',
        timeId: 'lseTime'
      },
      Tokyo: {
        name: 'Tokyo',
        timezone: 'Asia/Tokyo',
        openHour: 9, openMinute: 0,
        closeHour: 15, closeMinute: 0,
        weekdays: [1, 2, 3, 4, 5],
        itemId: 'marketTokyo',
        dotId: 'tokyoStatusDot',
        textId: 'tokyoStatusText',
        timeId: 'tokyoTime'
      },
      HongKong: {
        name: 'Hong Kong',
        timezone: 'Asia/Hong_Kong',
        openHour: 9, openMinute: 30,
        closeHour: 16, closeMinute: 0,
        weekdays: [1, 2, 3, 4, 5],
        itemId: 'marketHongKong',
        dotId: 'hkStatusDot',
        textId: 'hkStatusText',
        timeId: 'hkTime'
      },
      Sydney: {
        name: 'Sydney',
        timezone: 'Australia/Sydney',
        openHour: 10, openMinute: 0,
        closeHour: 16, closeMinute: 0,
        weekdays: [1, 2, 3, 4, 5],
        itemId: 'marketSydney',
        dotId: 'sydneyStatusDot',
        textId: 'sydneyStatusText',
        timeId: 'sydneyTime'
      },
      Frankfurt: {
        name: 'Frankfurt',
        timezone: 'Europe/Berlin',
        openHour: 9, openMinute: 0,
        closeHour: 17, closeMinute: 30,
        weekdays: [1, 2, 3, 4, 5],
        itemId: 'marketFrankfurt',
        dotId: 'frankfurtStatusDot',
        textId: 'frankfurtStatusText',
        timeId: 'frankfurtTime'
      }
    };

    function getMarketTime(timezone) {
      return new Date(new Date().toLocaleString('en-US', { timeZone: timezone }));
    }

    function formatTime(hours, minutes) {
      return String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0');
    }

    function formatTimeDiff(diffMs) {
      const hours = Math.floor(diffMs / (1000 * 60 * 60));
      const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
      if (hours > 0) {
        return hours + 'h ' + minutes + 'm';
      }
      return minutes + 'm';
    }

    function isMarketOpen(config) {
      const now = getMarketTime(config.timezone);
      const dayOfWeek = now.getDay();

      // Check if it's a weekday
      if (!config.weekdays.includes(dayOfWeek)) {
        return { isOpen: false, status: 'Weekend' };
      }

      const currentMinutes = now.getHours() * 60 + now.getMinutes();
      const openMinutes = config.openHour * 60 + config.openMinute;
      const closeMinutes = config.closeHour * 60 + config.closeMinute;

      if (currentMinutes >= openMinutes && currentMinutes < closeMinutes) {
        // Market is open - show time until close
        const closeTime = new Date(now);
        closeTime.setHours(config.closeHour, config.closeMinute, 0, 0);
        const timeUntilClose = closeTime - now;
        return {
          isOpen: true,
          status: 'Open',
          timeInfo: 'Closes in ' + formatTimeDiff(timeUntilClose)
        };
      } else {
        // Market is closed - calculate time until open
        let nextOpen = new Date(now);

        if (currentMinutes >= closeMinutes) {
          // After close today, next open is tomorrow or Monday
          nextOpen.setDate(nextOpen.getDate() + 1);
        }

        // Find next trading day
        while (!config.weekdays.includes(nextOpen.getDay())) {
          nextOpen.setDate(nextOpen.getDate() + 1);
        }

        nextOpen.setHours(config.openHour, config.openMinute, 0, 0);
        const timeUntilOpen = nextOpen - now;

        return {
          isOpen: false,
          status: 'Closed',
          timeInfo: 'Opens in ' + formatTimeDiff(timeUntilOpen)
        };
      }
    }

    function updateMarketHours() {
      Object.entries(marketConfig).forEach(([key, config]) => {
        const result = isMarketOpen(config);
        const itemEl = document.getElementById(config.itemId);
        const dotEl = document.getElementById(config.dotId);
        const textEl = document.getElementById(config.textId);
        const timeEl = document.getElementById(config.timeId);

        if (itemEl && dotEl && textEl && timeEl) {
          // Update item class
          itemEl.className = 'market-item ' + (result.isOpen ? 'open' : 'closed');

          // Update dot
          dotEl.className = 'market-status-dot ' + (result.isOpen ? 'open' : 'closed');

          // Update status text
          textEl.textContent = result.status;
          textEl.className = 'market-status-text ' + (result.isOpen ? 'open' : '');

          // Update time info
          timeEl.textContent = result.timeInfo || '';
        }
      });
    }

    // Initialize market hours and update every minute
    updateMarketHours();
    setInterval(updateMarketHours, 60000);

    // Render Top Pick item
    function renderTopPick(pick, container) {
      const div = document.createElement('div');
      div.className = 'pick-item';
      div.onclick = function() { openBinance(pick.symbol); };

      // Header with symbol, sparkline and score
      const header = document.createElement('div');
      header.className = 'pick-header';

      // Left side: symbol
      const symbol = document.createElement('span');
      symbol.className = 'pick-symbol ' + pick.direction.toLowerCase();
      symbol.textContent = pick.symbol;

      // Right side container: sparkline + score
      const headerRight = document.createElement('div');
      headerRight.className = 'pick-header-left';

      // Sparkline container (small, in header)
      const sparklineContainer = document.createElement('div');
      sparklineContainer.className = 'pick-sparkline';

      // Fetch and add sparkline asynchronously
      fetchPriceHistory(pick.symbol).then(history => {
        if (history && history.length > 0) {
          const sparkline = createSparkline(history, 70, 24);
          if (sparkline) {
            sparklineContainer.appendChild(sparkline);
          }
        }
      });

      const score = document.createElement('span');
      score.className = 'pick-score';
      score.textContent = pick.score + ' pts';

      headerRight.appendChild(sparklineContainer);
      headerRight.appendChild(score);

      header.appendChild(symbol);
      header.appendChild(headerRight);

      // Funding info
      const funding = document.createElement('div');
      funding.className = 'pick-funding';

      const fundingBadge = document.createElement('span');
      fundingBadge.className = 'pick-funding-badge ' + pick.fundingDirection.toLowerCase();
      fundingBadge.textContent = pick.fundingDirection === 'EARN' ? ' EARN' : ' PAY';

      const fundingRate = document.createElement('span');
      fundingRate.className = 'pick-funding-rate';
      fundingRate.textContent = pick.estimatedFundingPnl + ' / 8h';

      funding.appendChild(fundingBadge);
      funding.appendChild(fundingRate);

      // Meta tags
      const meta = document.createElement('div');
      meta.className = 'pick-meta';

      const typeTag = document.createElement('span');
      typeTag.className = 'pick-tag';
      typeTag.textContent = pick.entryType;
      meta.appendChild(typeTag);

      if (pick.momentum !== 'WEAK') {
        const momentumTag = document.createElement('span');
        momentumTag.className = 'pick-tag momentum-' + pick.momentum.toLowerCase();
        momentumTag.textContent = pick.momentum + ' momentum';
        meta.appendChild(momentumTag);
      }

      if (pick.urgency === 'NOW' || pick.urgency === 'WAIT') {
        const urgencyTag = document.createElement('span');
        urgencyTag.className = 'pick-tag urgency-' + pick.urgency.toLowerCase();
        urgencyTag.textContent = pick.urgency === 'NOW' ? ' NOW' : ' WAIT';
        meta.appendChild(urgencyTag);
      }

      const changeTag = document.createElement('span');
      changeTag.className = 'pick-tag';
      changeTag.textContent = (pick.change24h >= 0 ? '+' : '') + pick.change24h + '% 24h';
      meta.appendChild(changeTag);

      // Levels
      const levels = document.createElement('div');
      levels.className = 'pick-levels';

      var slLevel = document.createElement('div');
      slLevel.className = 'pick-level';
      slLevel.innerHTML = '<span class="pick-level-label">SL:</span><span class="pick-level-value sl">$' + pick.stopLoss.toFixed(4) + '</span>';

      var tpLevel = document.createElement('div');
      tpLevel.className = 'pick-level';
      tpLevel.innerHTML = '<span class="pick-level-label">TP:</span><span class="pick-level-value tp">$' + pick.takeProfit.toFixed(4) + '</span>';

      var levLevel = document.createElement('div');
      levLevel.className = 'pick-level';
      levLevel.innerHTML = '<span class="pick-level-label">Lev:</span><span class="pick-level-value lev">' + pick.suggestedLeverage + 'x</span>';

      var rrLevel = document.createElement('div');
      rrLevel.className = 'pick-level';
      rrLevel.innerHTML = '<span class="pick-level-label">R:R:</span><span class="pick-level-value">' + pick.riskRewardRatio + '</span>';

      levels.appendChild(slLevel);
      levels.appendChild(tpLevel);
      levels.appendChild(levLevel);
      levels.appendChild(rrLevel);

      // Reasons
      const reasons = document.createElement('div');
      reasons.className = 'pick-reasons';
      reasons.textContent = pick.reasons ? pick.reasons.slice(0, 2).join('  ') : '';

      // Build item
      div.appendChild(header);
      div.appendChild(funding);
      div.appendChild(meta);
      div.appendChild(levels);
      div.appendChild(reasons);

      container.appendChild(div);
    }

    // Render Top Picks
    function renderTopPicks(data) {
      if (!data || !data.topPicks) return;

      // Clear containers
      while (topLongPicks.firstChild) topLongPicks.removeChild(topLongPicks.firstChild);
      while (topShortPicks.firstChild) topShortPicks.removeChild(topShortPicks.firstChild);

      var longs = data.topPicks.longs || [];
      var shorts = data.topPicks.shorts || [];

      // Render longs
      if (longs.length > 0) {
        longs.forEach(function(pick) { renderTopPick(pick, topLongPicks); });
        topLongCount.textContent = longs.length;
      } else {
        topLongPicks.innerHTML = '<div class="empty-state">No long picks available</div>';
        topLongCount.textContent = '0';
      }

      // Render shorts
      if (shorts.length > 0) {
        shorts.forEach(function(pick) { renderTopPick(pick, topShortPicks); });
        topShortCount.textContent = shorts.length;
      } else {
        topShortPicks.innerHTML = '<div class="empty-state">No short picks available</div>';
        topShortCount.textContent = '0';
      }
    }

    // Main update handler
    socket.on('update', function(data) {
      console.log('Received update:', {
        topMovers: data.topMovers ? data.topMovers.length : 0,
        velocityAlerts: data.velocityAlerts ? data.velocityAlerts.length : 0,
        volumeSpikes: data.volumeSpikes ? data.volumeSpikes.length : 0,
        smartSignalsLong: data.smartSignalsLong ? data.smartSignalsLong.length : 0,
        smartSignalsShort: data.smartSignalsShort ? data.smartSignalsShort.length : 0
      });

      // Update status
      if (data.status === 'connected') {
        statusDot.classList.add('connected');
      } else {
        statusDot.classList.remove('connected');
      }
      statusText.textContent = data.status === 'connected' ? 'Connected' : 'Disconnected';
      symbolCount.textContent = data.symbolCount;
      lastUpdate.textContent = new Date(data.timestamp).toLocaleTimeString();

      // Clear all panels
      Object.values(panels).forEach(clearPanel);

      // Smart Long Signals
      if (data.smartSignalsLong && data.smartSignalsLong.length > 0) {
        data.smartSignalsLong.forEach(function(s) { renderSmartSignal(s, panels.smartLong); });
        badges.long.textContent = data.smartSignalsLong.length;
      } else {
        renderEmptyState(panels.smartLong, 'No long signals');
        badges.long.textContent = '0';
      }

      // Smart Short Signals
      if (data.smartSignalsShort && data.smartSignalsShort.length > 0) {
        data.smartSignalsShort.forEach(function(s) { renderSmartSignal(s, panels.smartShort); });
        badges.short.textContent = data.smartSignalsShort.length;
      } else {
        renderEmptyState(panels.smartShort, 'No short signals');
        badges.short.textContent = '0';
      }

      // Reversal Signals
      if (data.reversalSignals && data.reversalSignals.length > 0) {
        data.reversalSignals.forEach(function(s) { renderReversalSignal(s, panels.reversal); });
        badges.reversal.textContent = data.reversalSignals.length;
      } else {
        renderEmptyState(panels.reversal, 'No reversal signals');
        badges.reversal.textContent = '0';
      }

      // Early Entries
      if (data.earlyEntries && data.earlyEntries.length > 0) {
        data.earlyEntries.forEach(function(s) { renderSmartSignal(s, panels.earlyEntries); });
        badges.early.textContent = data.earlyEntries.length;
      } else {
        renderEmptyState(panels.earlyEntries, 'No early entries');
        badges.early.textContent = '0';
      }

      // Breakout Candidates
      if (data.breakoutCandidates && data.breakoutCandidates.length > 0) {
        data.breakoutCandidates.forEach(function(s) { renderSmartSignal(s, panels.breakout); });
        badges.breakout.textContent = data.breakoutCandidates.length;
      } else {
        renderEmptyState(panels.breakout, 'No breakout candidates');
        badges.breakout.textContent = '0';
      }

      // Low Risk Setups
      if (data.lowRiskSetups && data.lowRiskSetups.length > 0) {
        data.lowRiskSetups.forEach(function(s) { renderSmartSignal(s, panels.lowRisk); });
        badges.lowRisk.textContent = data.lowRiskSetups.length;
      } else {
        renderEmptyState(panels.lowRisk, 'No low risk setups');
        badges.lowRisk.textContent = '0';
      }

      // Top Movers - WITH SPARKLINES
      try {
        if (data.topMovers && data.topMovers.length > 0) {
          console.log('Rendering topMovers:', data.topMovers[0]);
          data.topMovers.forEach(function(m) {
            renderItemWithSparkline(m, panels.topMovers, {
              valueField: 'change24h',
              directionField: 'change24h',
              colorSymbol: true,
              metaFormat: function(d) { return '$' + formatNumber(d.lastPrice); },
              showSparkline: true
            });
          });
          badges.movers.textContent = data.topMovers.length;
        } else {
          renderEmptyState(panels.topMovers);
          badges.movers.textContent = '0';
        }
      } catch(e) {
        console.error('Error rendering topMovers:', e);
      }

      // Velocity Alerts - WITH SPARKLINES
      if (data.velocityAlerts && data.velocityAlerts.length > 0) {
        data.velocityAlerts.forEach(function(v) {
          renderItemWithSparkline(v, panels.velocity, {
            valueFormat: function(d) { return formatPercent(d.velocity) + '/min'; },
            valueField: 'velocity',
            directionField: 'velocity',
            colorSymbol: true,
            metaFormat: function(d) { return d.acceleration > 0 ? ' Accelerating' : ' Steady'; },
            showSparkline: true
          });
        });
        badges.velocity.textContent = data.velocityAlerts.length;
      } else {
        renderEmptyState(panels.velocity);
        badges.velocity.textContent = '0';
      }

      // Volume Spikes - WITH SPARKLINES
      if (data.volumeSpikes && data.volumeSpikes.length > 0) {
        data.volumeSpikes.forEach(function(v) {
          renderItemWithSparkline(v, panels.volume, {
            valueFormat: function(d) { return d.multiplier.toFixed(1) + 'x avg'; },
            valueField: 'multiplier',
            directionField: 'priceChange',
            colorSymbol: true,
            metaFormat: function(d) { return formatPercent(d.priceChange); },
            showSparkline: true
          });
        });
        badges.volume.textContent = data.volumeSpikes.length;
      } else {
        renderEmptyState(panels.volume);
        badges.volume.textContent = '0';
      }

      // High Conviction
      if (data.highConviction && data.highConviction.length > 0) {
        data.highConviction.forEach(function(h) {
          // Determine direction from direction field or change24h
          var dirVal = h.direction === 'LONG' ? 1 : (h.direction === 'SHORT' ? -1 : (h.details && h.details.change24h ? h.details.change24h : 0));
          renderItem(h, panels.conviction, {
            valueFormat: function(d) { return 'Score: ' + d.score.toFixed(0); },
            valueField: 'score',
            directionField: null,
            colorSymbol: true,
            metaFormat: function(d) { return d.details && d.details.change24h ? formatPercent(d.details.change24h) : d.direction; }
          });
          // Manually apply direction class since we need custom logic
          var lastItem = panels.conviction.lastChild;
          if (lastItem) {
            var sym = lastItem.querySelector('.item-symbol');
            var val = lastItem.querySelector('.item-value');
            if (dirVal > 0) {
              if (sym) sym.classList.add('positive');
              if (val) val.classList.add('positive');
            } else if (dirVal < 0) {
              if (sym) sym.classList.add('negative');
              if (val) val.classList.add('negative');
            }
          }
        });
        badges.conviction.textContent = data.highConviction.length;
      } else {
        renderEmptyState(panels.conviction);
        badges.conviction.textContent = '0';
      }

      // Funding Rates
      if (data.fundingRates && data.fundingRates.length > 0) {
        data.fundingRates.forEach(function(f) {
          renderItem(f, panels.funding, {
            valueFormat: function(d) { return (d.fundingRate * 100).toFixed(4) + '%'; },
            valueField: 'fundingRate',
            directionField: 'fundingRate',
            colorSymbol: true,
            metaFormat: function(d) { return d.signal; }
          });
        });
        badges.funding.textContent = data.fundingRates.length;
      } else {
        renderEmptyState(panels.funding);
        badges.funding.textContent = '0';
      }

      // Squeeze Setups
      if (data.squeezeSetups && data.squeezeSetups.length > 0) {
        data.squeezeSetups.forEach(function(s) {
          renderItem(s, panels.squeeze, {
            valueFormat: function(d) { return d.signal; },
            metaFormat: function(d) { return 'Funding: ' + (d.fundingRate * 100).toFixed(4) + '%'; }
          });
        });
        badges.squeeze.textContent = data.squeezeSetups.length;
      } else {
        renderEmptyState(panels.squeeze);
        badges.squeeze.textContent = '0';
      }

      // Open Interest
      if (data.openInterest && data.openInterest.length > 0) {
        data.openInterest.forEach(function(o) {
          renderItem(o, panels.oi, {
            valueFormat: function(d) { return formatPercent(d.oiChange); },
            valueField: 'oiChange',
            directionField: 'oiChange',
            colorSymbol: true,
            metaFormat: function(d) { return d.signal; },
            subFormat: function(d) { return 'OI: $' + formatNumber(d.openInterest); }
          });
        });
        badges.oi.textContent = data.openInterest.length;
      } else {
        renderEmptyState(panels.oi);
        badges.oi.textContent = '0';
      }

      // Multi-Timeframe
      if (data.multiTimeframe && data.multiTimeframe.length > 0) {
        data.multiTimeframe.forEach(function(m) {
          renderItem(m, panels.mtf, {
            valueFormat: function(d) { return d.alignment; },
            metaFormat: function(d) { return '15m: ' + formatPercent(d.change15m) + ' | 1h: ' + formatPercent(d.change1h); },
            subFormat: function(d) { return '4h: ' + formatPercent(d.change4h) + ' | RSI: ' + d.rsi1h.toFixed(0); }
          });
        });
        badges.mtf.textContent = data.multiTimeframe.length;
      } else {
        renderEmptyState(panels.mtf);
        badges.mtf.textContent = '0';
      }

      // RSI Extremes
      if (data.rsiExtremes && data.rsiExtremes.length > 0) {
        data.rsiExtremes.forEach(function(r) {
          renderItem(r, panels.rsi, {
            valueFormat: function(d) { return 'RSI: ' + d.rsi1h.toFixed(1); },
            valueField: 'rsi1h',
            metaFormat: function(d) { return d.rsi1h < 30 ? 'OVERSOLD' : 'OVERBOUGHT'; }
          });
        });
        badges.rsi.textContent = data.rsiExtremes.length;
      } else {
        renderEmptyState(panels.rsi);
        badges.rsi.textContent = '0';
      }

      // Divergences
      if (data.divergences && data.divergences.length > 0) {
        data.divergences.forEach(function(d) {
          renderItem(d, panels.divergence, {
            valueFormat: function(dd) { return dd.divergence; },
            metaFormat: function(dd) { return 'RSI: ' + dd.rsi1h.toFixed(0) + ' | ' + formatPercent(dd.change24h); }
          });
        });
        badges.div.textContent = data.divergences.length;
      } else {
        renderEmptyState(panels.divergence);
        badges.div.textContent = '0';
      }

      // Liquidation Alerts
      if (data.liquidations && data.liquidations.length > 0) {
        data.liquidations.forEach(function(l) {
          var dirVal = l.side === 'LONG' ? -1 : 1; // Opposite direction for opportunity
          renderItem(l, panels.liquidation, {
            valueFormat: function(d) { return d.intensity; },
            directionField: null,
            colorSymbol: true,
            metaFormat: function(d) { return '$' + formatNumber(d.estimatedAmount) + ' ' + d.side + ' liq'; }
          });
          var lastItem = panels.liquidation.lastChild;
          if (lastItem) {
            var sym = lastItem.querySelector('.item-symbol');
            if (dirVal > 0 && sym) sym.classList.add('positive');
            else if (dirVal < 0 && sym) sym.classList.add('negative');
          }
        });
        badges.liq.textContent = data.liquidations.length;
      } else {
        renderEmptyState(panels.liquidation, 'No liquidation alerts');
        badges.liq.textContent = '0';
      }

      // Whale Alerts
      if (data.whaleAlerts && data.whaleAlerts.length > 0) {
        data.whaleAlerts.forEach(function(w) {
          var dirVal = w.direction === 'BULLISH' ? 1 : -1;
          renderItem(w, panels.whale, {
            valueFormat: function(d) { return d.type.replace(/_/g, ' '); },
            directionField: null,
            colorSymbol: true,
            metaFormat: function(d) { return '$' + formatNumber(d.estimatedSize) + ' ' + d.direction; }
          });
          var lastItem = panels.whale.lastChild;
          if (lastItem) {
            var sym = lastItem.querySelector('.item-symbol');
            var val = lastItem.querySelector('.item-value');
            if (dirVal > 0) {
              if (sym) sym.classList.add('positive');
              if (val) val.classList.add('positive');
            } else {
              if (sym) sym.classList.add('negative');
              if (val) val.classList.add('negative');
            }
          }
        });
        badges.whale.textContent = data.whaleAlerts.length;
      } else {
        renderEmptyState(panels.whale, 'No whale activity');
        badges.whale.textContent = '0';
      }

      // BTC Correlation
      if (data.correlations && data.correlations.length > 0) {
        data.correlations.forEach(function(c) {
          var dirVal = c.outperformance;
          renderItem(c, panels.correlation, {
            valueFormat: function(d) { return d.signal; },
            directionField: 'outperformance',
            colorSymbol: true,
            metaFormat: function(d) { return 'Corr: ' + d.btcCorrelation.toFixed(2) + ' | ' + formatPercent(d.outperformance); }
          });
        });
        badges.corr.textContent = data.correlations.length;
      } else {
        renderEmptyState(panels.correlation, 'No correlation alerts');
        badges.corr.textContent = '0';
      }

      // Pattern Recognition
      if (data.patterns && data.patterns.length > 0) {
        data.patterns.forEach(function(p) {
          var dirVal = p.direction === 'BULLISH' ? 1 : (p.direction === 'BEARISH' ? -1 : 0);
          renderItem(p, panels.pattern, {
            valueFormat: function(d) { return d.pattern.replace(/_/g, ' '); },
            directionField: null,
            colorSymbol: true,
            metaFormat: function(d) { return d.description; },
            subFormat: function(d) { return 'Conf: ' + d.confidence + '%'; }
          });
          var lastItem = panels.pattern.lastChild;
          if (lastItem) {
            var sym = lastItem.querySelector('.item-symbol');
            var val = lastItem.querySelector('.item-value');
            if (dirVal > 0) {
              if (sym) sym.classList.add('positive');
              if (val) val.classList.add('positive');
            } else if (dirVal < 0) {
              if (sym) sym.classList.add('negative');
              if (val) val.classList.add('negative');
            }
          }
        });
        badges.pattern.textContent = data.patterns.length;
      } else {
        renderEmptyState(panels.pattern, 'No patterns detected');
        badges.pattern.textContent = '0';
      }

      // Entry Signals Long
      if (data.entrySignals && data.entrySignals.length > 0) {
        var longSignals = data.entrySignals.filter(function(s) { return s.direction === 'LONG'; });
        var shortSignals = data.entrySignals.filter(function(s) { return s.direction === 'SHORT'; });

        if (longSignals.length > 0) {
          longSignals.forEach(function(s) { renderEntrySignal(s, panels.entryLong); });
          badges.entryLong.textContent = longSignals.length;
        } else {
          renderEmptyState(panels.entryLong, 'No long entries');
          badges.entryLong.textContent = '0';
        }

        if (shortSignals.length > 0) {
          shortSignals.forEach(function(s) { renderEntrySignal(s, panels.entryShort); });
          badges.entryShort.textContent = shortSignals.length;
        } else {
          renderEmptyState(panels.entryShort, 'No short entries');
          badges.entryShort.textContent = '0';
        }
      } else {
        renderEmptyState(panels.entryLong, 'No long entries');
        renderEmptyState(panels.entryShort, 'No short entries');
        badges.entryLong.textContent = '0';
        badges.entryShort.textContent = '0';
      }

      // Update Market Sentiment
      if (data.marketSentiment) {
        updateSentiment(data.marketSentiment);
      }

      // Update Win Rate Stats
      if (data.winRateStats) {
        updateWinRateStats(data.winRateStats);
      }

      // Update Performance Tracking Panel
      updatePerformancePanel(data.winRateStats, data.recentSignals);

      // Update ML Status
      if (data.mlStatus) {
        updateMLStatus(data.mlStatus, data.mlFeatureCounts);
      }

      // Handle Notifications
      if (data.notifications && data.notifications.length > 0) {
        data.notifications.forEach(function(n) {
          renderNotification(n);
        });
      }

      // Render Top Picks
      renderTopPicks(data);
    });

    // Filter handlers
    minVolumeFilter.addEventListener('change', function() {
      socket.emit('setFilter', { minVolume24h: parseInt(minVolumeFilter.value) });
    });

    presetButtons.forEach(function(btn) {
      btn.addEventListener('click', function() {
        presetButtons.forEach(function(b) { b.classList.remove('active'); });
        btn.classList.add('active');
        fetch('/api/filters/preset/' + btn.dataset.preset, { method: 'POST' });
      });
    });

    // ============================================
    // CONNECTION STATUS MANAGER
    // ============================================
    const ConnectionManager = {
      overlay: document.getElementById('connectionOverlay'),
      overlayMessage: document.getElementById('connectionMessage'),
      overlaySubmessage: document.getElementById('connectionSubmessage'),
      retryCountEl: document.getElementById('connectionRetryCount'),
      retryNumberEl: document.getElementById('retryNumber'),
      banner: document.getElementById('connectionBanner'),
      bannerMessage: document.getElementById('bannerMessage'),
      retryCount: 0,
      isFirstConnect: true,
      wasConnected: false,
      reconnectTimeout: null,

      init: function() {
        // Show overlay on initial load
        this.showOverlay('Connecting to server...', 'Establishing WebSocket connection to receive real-time data');
      },

      showOverlay: function(message, submessage) {
        this.overlayMessage.textContent = message || 'Connecting...';
        this.overlaySubmessage.textContent = submessage || '';
        this.overlay.classList.add('visible');
      },

      hideOverlay: function() {
        this.overlay.classList.remove('visible');
      },

      showBanner: function(message, type) {
        this.banner.className = 'connection-banner visible ' + (type || '');
        this.bannerMessage.textContent = message;

        // Auto-hide success banner after 3 seconds
        if (type === 'connected') {
          setTimeout(() => {
            this.hideBanner();
          }, 3000);
        }
      },

      hideBanner: function() {
        this.banner.classList.remove('visible');
      },

      updateStatusDot: function(status) {
        statusDot.classList.remove('connected', 'disconnected', 'reconnecting');
        if (status === 'connected') {
          statusDot.classList.add('connected');
        } else if (status === 'reconnecting') {
          statusDot.classList.add('reconnecting');
        } else {
          statusDot.classList.add('disconnected');
        }
      },

      onConnect: function() {
        console.log('Connected to server');
        this.hideOverlay();
        this.updateStatusDot('connected');
        statusText.textContent = 'Connected';

        if (!this.isFirstConnect && this.wasConnected) {
          // Reconnected after disconnection
          this.showBanner('Connection restored', 'connected');
        }

        this.isFirstConnect = false;
        this.wasConnected = true;
        this.retryCount = 0;
        this.retryCountEl.style.display = 'none';

        if (this.reconnectTimeout) {
          clearTimeout(this.reconnectTimeout);
          this.reconnectTimeout = null;
        }
      },

      onDisconnect: function(reason) {
        console.log('Disconnected:', reason);
        this.wasConnected = true;
        this.updateStatusDot('disconnected');
        statusText.textContent = 'Disconnected';

        // Show banner immediately
        this.showBanner('Connection lost - Reconnecting...', 'reconnecting');

        // If disconnected for more than 5 seconds, show overlay
        this.reconnectTimeout = setTimeout(() => {
          this.showOverlay('Connection Lost', 'Attempting to reconnect to the server...');
          this.retryCountEl.style.display = 'block';
        }, 5000);
      },

      onReconnecting: function(attemptNumber) {
        console.log('Reconnecting, attempt:', attemptNumber);
        this.retryCount = attemptNumber;
        this.retryNumberEl.textContent = attemptNumber;
        this.updateStatusDot('reconnecting');
        statusText.textContent = 'Reconnecting...';

        this.showBanner('Reconnecting... (attempt ' + attemptNumber + ')', 'reconnecting');

        if (attemptNumber > 2) {
          this.showOverlay('Reconnecting...', 'Attempt ' + attemptNumber + ' - Please wait');
          this.retryCountEl.style.display = 'block';
        }
      },

      onReconnectError: function(error) {
        console.log('Reconnect error:', error);
        this.overlaySubmessage.textContent = 'Connection failed. Retrying...';
      },

      onReconnectFailed: function() {
        console.log('Reconnect failed');
        this.showOverlay('Connection Failed', 'Unable to connect to the server. Please refresh the page.');
        this.showBanner('Connection failed - Please refresh', '');
        this.retryCountEl.style.display = 'none';
      }
    };

    // Initialize connection manager
    ConnectionManager.init();

    // Socket event handlers
    socket.on('connect', function() {
      ConnectionManager.onConnect();
    });

    socket.on('disconnect', function(reason) {
      ConnectionManager.onDisconnect(reason);
    });

    socket.io.on('reconnect_attempt', function(attemptNumber) {
      ConnectionManager.onReconnecting(attemptNumber);
    });

    socket.io.on('reconnect_error', function(error) {
      ConnectionManager.onReconnectError(error);
    });

    socket.io.on('reconnect_failed', function() {
      ConnectionManager.onReconnectFailed();
    });

    socket.io.on('reconnect', function() {
      ConnectionManager.onConnect();
    });

    // View toggle handler - Default to compact mode
    var viewToggle = document.getElementById('viewToggle');
    var mainContainer = document.querySelector('.main-container');
    var isCompactView = true;

    // Set compact mode as default on load
    mainContainer.classList.add('compact-view');
    viewToggle.textContent = 'Cards';
    viewToggle.classList.add('active');

    viewToggle.addEventListener('click', function() {
      isCompactView = !isCompactView;
      if (isCompactView) {
        mainContainer.classList.add('compact-view');
        viewToggle.textContent = 'Cards';
        viewToggle.classList.add('active');
      } else {
        mainContainer.classList.remove('compact-view');
        viewToggle.textContent = 'Compact';
        viewToggle.classList.remove('active');
      }
    });

    // Set default filter to ALL on page load
    fetch('/api/filters/preset/all', { method: 'POST' });

    // ============================================
    // SKELETON LOADER MODULE
    // ============================================
    const SkeletonLoader = {
      // Generate skeleton items for basic panels
      createBasicSkeletons: function(count) {
        let html = '';
        for (let i = 0; i < count; i++) {
          html += '<div class="skeleton-item"><div class="skeleton skeleton-symbol"></div><div class="skeleton skeleton-value"></div></div>';
        }
        return html;
      },

      // Generate skeleton items for smart signal panels
      createSmartSkeletons: function(count) {
        let html = '';
        for (let i = 0; i < count; i++) {
          html += '<div class="skeleton-smart-item">' +
            '<div class="skeleton-header"><div class="skeleton skeleton-symbol"></div><div class="skeleton skeleton-badge"></div></div>' +
            '<div class="skeleton skeleton-bar"></div>' +
            '<div class="skeleton-meta"><div class="skeleton skeleton-tag"></div><div class="skeleton skeleton-tag"></div><div class="skeleton skeleton-tag"></div></div>' +
            '</div>';
        }
        return html;
      },

      // Show skeletons in all panels
      showAll: function() {
        // Smart signal panels
        const smartPanels = ['smartLongPanel', 'smartShortPanel', 'reversalPanel', 'earlyEntriesPanel', 'breakoutPanel', 'lowRiskPanel'];
        smartPanels.forEach(function(id) {
          const el = document.getElementById(id);
          if (el) el.innerHTML = SkeletonLoader.createSmartSkeletons(3);
        });

        // Basic panels
        const basicPanels = ['topMoversPanel', 'velocityPanel', 'volumePanel', 'convictionPanel', 'fundingPanel', 'squeezePanel', 'oiPanel', 'mtfPanel', 'rsiPanel', 'divergencePanel', 'liquidationPanel', 'whalePanel', 'correlationPanel', 'patternPanel', 'entryLongPanel', 'entryShortPanel'];
        basicPanels.forEach(function(id) {
          const el = document.getElementById(id);
          if (el) el.innerHTML = SkeletonLoader.createBasicSkeletons(4);
        });

        // Top picks
        if (topLongPicks) topLongPicks.innerHTML = SkeletonLoader.createSmartSkeletons(2);
        if (topShortPicks) topShortPicks.innerHTML = SkeletonLoader.createSmartSkeletons(2);
      }
    };

    // Show skeletons on initial load
    SkeletonLoader.showAll();

    // ============================================
    // DRAG AND DROP MODULE
    // ============================================
    const DragDropManager = {
      draggedElement: null,
      originalIndex: -1,
      layoutModified: false,

      init: function() {
        // Wait for DOM to be ready
        setTimeout(function() {
          DragDropManager.setupPanels();
          DragDropManager.restoreLayout();
        }, 100);
      },

      setupPanels: function() {
        // Get all panel grids
        const panelGrids = document.querySelectorAll('.panels-grid, .smart-signals-section');

        panelGrids.forEach(function(grid) {
          const panels = grid.querySelectorAll('.panel');

          panels.forEach(function(panel, index) {
            // Add draggable attributes
            panel.classList.add('draggable');
            panel.setAttribute('draggable', 'true');
            panel.dataset.originalIndex = index;
            panel.dataset.gridId = grid.className;

            // Drag start
            panel.addEventListener('dragstart', function(e) {
              DragDropManager.draggedElement = panel;
              DragDropManager.originalIndex = index;
              panel.classList.add('dragging');
              e.dataTransfer.effectAllowed = 'move';
              e.dataTransfer.setData('text/plain', index.toString());
            });

            // Drag end
            panel.addEventListener('dragend', function(e) {
              panel.classList.remove('dragging');
              document.querySelectorAll('.panel.drag-over').forEach(function(p) {
                p.classList.remove('drag-over');
              });
              DragDropManager.draggedElement = null;
            });

            // Drag over
            panel.addEventListener('dragover', function(e) {
              e.preventDefault();
              e.dataTransfer.dropEffect = 'move';
              if (panel !== DragDropManager.draggedElement) {
                panel.classList.add('drag-over');
              }
            });

            // Drag leave
            panel.addEventListener('dragleave', function(e) {
              panel.classList.remove('drag-over');
            });

            // Drop
            panel.addEventListener('drop', function(e) {
              e.preventDefault();
              panel.classList.remove('drag-over');

              if (DragDropManager.draggedElement && panel !== DragDropManager.draggedElement) {
                // Get parent grid
                const parentGrid = panel.parentNode;

                // Get positions
                const allPanels = Array.from(parentGrid.querySelectorAll('.panel'));
                const draggedIndex = allPanels.indexOf(DragDropManager.draggedElement);
                const targetIndex = allPanels.indexOf(panel);

                // Swap positions in DOM
                if (draggedIndex < targetIndex) {
                  parentGrid.insertBefore(DragDropManager.draggedElement, panel.nextSibling);
                } else {
                  parentGrid.insertBefore(DragDropManager.draggedElement, panel);
                }

                // Mark layout as modified
                DragDropManager.layoutModified = true;
                DragDropManager.saveLayout();
                DragDropManager.updateIndicator();
              }
            });
          });
        });

        // Setup reset button
        const resetBtn = document.getElementById('resetLayoutBtn');
        if (resetBtn) {
          resetBtn.addEventListener('click', function() {
            DragDropManager.resetLayout();
          });
        }
      },

      saveLayout: function() {
        const layout = {};
        const grids = document.querySelectorAll('.panels-grid, .smart-signals-section');

        grids.forEach(function(grid, gridIndex) {
          const panels = grid.querySelectorAll('.panel');
          const order = [];
          panels.forEach(function(panel) {
            // Use panel title as identifier
            const titleEl = panel.querySelector('.panel-title');
            if (titleEl) {
              order.push(titleEl.textContent.trim());
            }
          });
          layout['grid_' + gridIndex] = order;
        });

        sessionStorage.setItem('signalsense_layout', JSON.stringify(layout));
        sessionStorage.setItem('signalsense_layout_modified', 'true');
      },

      restoreLayout: function() {
        const savedLayout = sessionStorage.getItem('signalsense_layout');
        const isModified = sessionStorage.getItem('signalsense_layout_modified') === 'true';

        if (!savedLayout || !isModified) return;

        try {
          const layout = JSON.parse(savedLayout);
          const grids = document.querySelectorAll('.panels-grid, .smart-signals-section');

          grids.forEach(function(grid, gridIndex) {
            const savedOrder = layout['grid_' + gridIndex];
            if (!savedOrder) return;

            const panels = Array.from(grid.querySelectorAll('.panel'));
            const panelMap = {};

            // Create map of title -> panel
            panels.forEach(function(panel) {
              const titleEl = panel.querySelector('.panel-title');
              if (titleEl) {
                panelMap[titleEl.textContent.trim()] = panel;
              }
            });

            // Reorder panels based on saved order
            savedOrder.forEach(function(title) {
              const panel = panelMap[title];
              if (panel) {
                grid.appendChild(panel);
              }
            });
          });

          DragDropManager.layoutModified = true;
          DragDropManager.updateIndicator();
        } catch (e) {
          // Silently fail if layout can't be restored
        }
      },

      resetLayout: function() {
        sessionStorage.removeItem('signalsense_layout');
        sessionStorage.removeItem('signalsense_layout_modified');
        DragDropManager.layoutModified = false;
        DragDropManager.updateIndicator();
        // Reload page to restore original order
        location.reload();
      },

      updateIndicator: function() {
        const indicator = document.getElementById('layoutIndicator');
        const resetBtn = document.getElementById('resetLayoutBtn');

        if (DragDropManager.layoutModified) {
          if (indicator) {
            indicator.classList.add('modified');
            indicator.innerHTML = '<span></span> Layout customized';
          }
          if (resetBtn) {
            resetBtn.style.display = 'inline-block';
          }
        } else {
          if (indicator) {
            indicator.classList.remove('modified');
            indicator.innerHTML = '<span></span> Drag panels to rearrange';
          }
          if (resetBtn) {
            resetBtn.style.display = 'none';
          }
        }
      }
    };

    // Initialize drag and drop
    DragDropManager.init();

    // Check if layout was previously modified
    if (sessionStorage.getItem('signalsense_layout_modified') === 'true') {
      DragDropManager.layoutModified = true;
      DragDropManager.updateIndicator();
    }
  </script>
</body>
</html>
